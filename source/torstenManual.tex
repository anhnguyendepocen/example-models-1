\documentclass[11pt]{amsart}
%\documentclass[11pt]{article}
\usepackage{geometry}                % See geometry.pdf to learn the layout options. There are lots.
\geometry{letterpaper, width=7in, height=9in}                   % ... or a4paper or a5paper or ... 
\usepackage{graphicx}
\usepackage{pdfpages}
\usepackage{amssymb}
\usepackage{epstopdf}
\usepackage{color}
\usepackage{hyperref}
\usepackage{courier}
\usepackage{listings}
%\usepackage[titles]{tocloft}


\usepackage{siunitx}
\usepackage{booktabs}

%package for quotes
\usepackage{csquotes}
\usepackage{epigraph}

%% Code to break page before a section begins (some section are very short so this
%% doesn't always make sense. I'd rather break the page manually).
% \let\oldsection\section
% \renewcommand\section{\clearpage\oldsection}

\DeclareGraphicsRule{.tif}{png}{.png}{`convert #1 `dirname #1`/`basename #1 .tif`.png}
\DeclareGraphicsRule{.gif}{pdf}{.pdf}{`convert #1 `dirname #1`/`basename #1 .gif`.pdf}

   \newsavebox{\fmbox}
   \newenvironment{fmpage}[1]
     {\begin{lrbox}{\fmbox}\begin{minipage}{#1}}
     {\end{minipage}\end{lrbox}\fbox{\usebox{\fmbox}}}
     
\oddsidemargin 0in
\evensidemargin 0in

%\definecolor{MRGGreen}{rgb}{0,0.655,0.212}
\definecolor{MRGGreen}{rgb}{0, 0.350, 0.200}
\parskip 10pt
\parindent 0em

\lstset{columns=fullflexible, basicstyle=\ttfamily, xleftmargin=0.5cm, frame=tlbr,framesep=4pt, framerule=0pt}

%\usepackage[nottoc]{tocbibind}
%\usepackage[colorlinks=true,linkcolor=blue]{hyperref}
%\setcounter{tocdepth}{0}

%\cftsetindents{section}{0em}{2.3em}
%\cftsetindents{subsection}{0em}{4.3em}

\begin{document}

\begin{center}
\includegraphics[height=0.75in]{graphics/logo.jpg}\\
\textcolor{MRGGreen}{\sf
\begin{tabbing}
Metrum Research Group LLC \` 2 Tunxis Road, Suite 112 \\
Phone: 860.735.7043 \` Tariffville, CT 06081 \\
billgm@metrumrg.com \` metrumrg.com \\
\end{tabbing}
}
{\Huge \textcolor{MRGGreen}{\textbf{Torsten}} \\ \ \\  \huge A Prototype Library for Bayesian Pharmacometrics Modeling in Stan \\ \ \\
User Manual \\ \ \\ \ \\ \ \\
\Large Torsten Version 0.83 \\ for Stan Version 2.16.0 \\ \ \\
\large August 2017 }
\end{center}

\clearpage


\tableofcontents

\pagebreak

\section*{Development Team}
Bill Gillespie \\
\texttt{billg@metrumrg.com} \\
Metrum Research Group, LLC

Charles Margossian \\
\texttt{charles.margossian@columbia.edu} \\
Columbia University, Department of Statistics \\
(formally Metrum Research Group, LLC)

\section*{Acknowledgements}

{\bf Institutions} \ \\
We thank Metrum Research Group, Columbia University, and AstraZeneca.

{\bf Funding}  \ \\
This work was funded in part by the following organizations:
\begin{itemize}
  \item Office of Naval Research (ONR) contract N00014-16-P-2039 provided as part  of the Small Business Technology Transfer (STTR) program. The content of the information presented in this document does not necessarily reflect the position or policy of the Government and no official endorsement should be inferred.
  \item Bill \& Melinda Gates Foundation
\end{itemize}

{\bf Individuals} \ \\
We thank the Stan Development Team for giving us guidance on how to create new Stan functions and adding features to Stan's core language that facilitate building ODE-based models.

We also thank Kyle Baron and Hunter Ford for helpful advice on coding in C++ and using GitHub, Curtis Johnston for reviewing the User Manual, and Yaming Su for using Torsten and giving us feedback.

\pagebreak

\section{Introduction}
%\addcontentsline{toc}{section}{Introduction}

%\subsection{Goal and Scope of the Project} \ \\ \ \\ 
Stan is an open source probabilistic programing language designed primarily to do Bayesian data analysis \cite{Stan:2016}. Several of its features make it a powerful tool to specify and fit complex models. Notably, its language is extremely flexible and its No U-Turn Sampler (NUTS), an adaptative Hamiltonian Monte Carlo algorithm, has proven more efficient than commonly used Monte Carlo Markov Chains (MCMC) samplers for complex high dimensional problems \cite{HoffmanGelman:2014}. Our goal is to harness these innovative features and make Stan a better software for pharmacometrics modeling. Our efforts are twofold:
\begin{enumerate}
  \item We contribute to the development of new mathematical tools, such as functions that support differential equations based models, and implement them directly into Stan's core language.
  \item We develop Torsten, an extension with specialized pharmacometrics functions.
\end{enumerate}

Throughout the process, we work very closely with the Stan Development Team. We have benefited immensely from their mentorship, advice, and feedback. Just like Stan, Torsten is an open source project that fosters collaborative work. Interested in contributing? Shoot us an e-mail and we will help you help us (\url{billg@metrumrg.com})!

Torsten is licensed under the BSD 3-clause license.

\begin{fmpage}{\textwidth}
{\bf WARNING:} The current version of Torsten is a {\em prototype}. It is being released for review and comment, and to support limited research applications. It has not been rigorously tested and should not be used for critical applications without further testing or cross-checking by comparison with other methods. \\ \ \\
We encourage interested users to try Torsten out and are happy to assist. Please report issues, bugs, and feature requests on our GitHub page: \url{https://github.com/metrumresearchgroup/stan}.
\end{fmpage}


\subsection{Installing Torsten}  \ \\ \ \\  
Installation files are available on GitHub: \url{https://github.com/metrumresearchgroup/example-models}

There is currently no mechanism to install Torsten on top of your version of Stan. This is still a work in progress. In the meantime, we offer a version of Stan with Torsten built inside of it. Torsten 0.83 works with Stan 2.16.0. Torsten is built inside the Stan and Stan-math repositories and is agnostic to the interface. We offer support to install Torsten with RStan and CmdStan.

\subsubsection{Intalling Torsten with RStan} The easiest way to install the RStan interface with Stan and Torsten is to run the script \texttt{R/setupRTorsten.R}. You'll need to make a few minor adjustments, notably by specifying where you wish to install RStan (and its dependency StanHeaders). You may run into difficulty if Torsten is not up to date with Stan's last release\footnote{See issue \#3 on our GitHub issue tracker: \url{https://github.com/charlesm93/example-models/issues/3}}.

If you already have these packages installed, the script will not automatically overwrite them, which is why you should remove them prior to running \texttt{setupRTorsten.R}. 

The script currently doesn't install all the dependencies for RStan\footnote{See \url{https://github.com/stan-dev/rstan/wiki/RStan-Getting-Started} for details on RStan}. This is to prevent the edited StanHeaders package from getting overwritten by the \texttt{install.packages()} procedure. If you wish to install RStan's dependencies, you could run \texttt{install.package("rstan")}, remove the RStan and the StanHeaders packages and then run \texttt{SetupRTorsten.R}. We realize this is not optimal and are working on a more elegant solution.

\subsubsection{Installing Torsten with CmdStan} Similarly, you can install the CmdStan interface with Stan and Torsten using the bash file \texttt{setupTorsten.sh}\footnote{To get the development version of Torsten use \texttt{setupTorsten-dev.sh}.}.

\subsection{Overview} \ \\ \ \\
Torsten is a prototype pharmacometrics model library for use in Stan 2.16.0. The current version includes:
\begin{itemize}
  \item Specific linear compartment models:
  \begin{itemize}
    \item One compartment model with first order absorption
    \item Two compartment model with elimination from and first order absorption into central compartment
  \end{itemize}
  \item General linear compartment model described by a system of first-order \underline{linear} Ordinary Differential Equations (ODEs).
  \item General compartment model described by a system of first order ODEs
  \item Mix compartment model with forcing a PK function described by a One or Two compartment model, and forced states described by a system of first-order ODEs.
 \end{itemize}

The models and data format are based on NONMEM\textregistered\footnote{NONMEM\textregistered\ is licensed and distributed by ICON Development Solutions.}/NMTRAN/PREDPP conventions including:
\begin{itemize}
  \item Recursive calculation of model predictions
  \begin{itemize}
    \item This permits piecewise constant covariate values
  \end{itemize}
  \item Bolus or constant rate inputs into any compartment
  \item Handles single dose and multiple dose histories
  \item Handles steady state dosing histories
  \begin{itemize}
      \item Note: The infusion time must be shorter than the inter-dose interval.
  \end{itemize}
  \item Implemented NMTRAN data items include: TIME, EVID, CMT, AMT, RATE, ADDL, II, SS
\end{itemize}

In general, all continuous variables may be passed as parameters. A few exceptions apply \textit{to functions which use a numerical integrator} (i.e. the general and the mix compartment models). The below listed cases present technical difficulties, which we expect to overcome in Torsten's next release:
\begin{itemize}
  \item The RATE and TIME arguments must be fixed
  \item In the case of a multiple truncated infusion rate dosing regimen:
  \begin{itemize}
    \item The bioavailability (F) and the amount (AMT) must be fixed.
  \end{itemize}
\end{itemize}   

This library provides Stan language functions that calculate amounts in each compartment, given an event schedule and an ODE system.
    
\subsection{Implementation details}
\begin{itemize}
  \item Stan version 2.16.0
  \item All functions are programmed in C++ and are compatible with the Stan-math automatic differentiation library \cite{Carpenter:2015}
  \item All functions can be called directly in a Stan file in a manner identical to other built-in functions
  \item One and two compartment models: hand-coded analytical solutions
  \item General linear compartment models with semi-analytical solutions using the built-in Matrix Exponential function
  \item General compartment models with numerical solutions using built-in ODE integrators in Stan. The tuning parameters of the solver are adjustable. The steady state solution is calculated using a numerical algebraic solver (expected in Stan 2.17).
  \item Mix compartment model: the forcing PK function is solved analytically and the forced ODE system is solved numerically.
\end{itemize}



\subsection{Development plans} \ \\ \ \\
Our current plans for future development of Torsten include the following:
\begin{itemize}
  \item Build a system to easily share packages of Stan functions (written in C++ or in the Stan language)
  \item Allow numerical methods to handle RATE, AMT, TIME, and the bioavailability fraction (F) as parameters in all cases.
  \item Optimize Matrix exponential functions
  \begin{itemize}
    \item Function for the action of Matrix Exponential on a vector
    \item Hand-coded gradients
    \item Special algorithm for matrices with special properties
  \end{itemize}
  \item Fix issue that arises when computing the adjoint of the lag time parameter (in a dosing compartment) evaluated at $t_{lag} = 0$. 
  \item Make the following arguments optional
  \begin{itemize}
    \item \texttt{biovar} and \texttt{tlag}, respectively used for the bioavailability fraction and the lag times in each compartment
    \item Tuning parameters of the ODE integrators for the general compartmental function.
  \end{itemize}
  \item Extend formal tests
  \begin{itemize}
    \item We want more C++ Google unit tests to address cases users may encounter 
    \item Comparison with simulations from the R package \textit{mrgsolve} and the software NONMEM\textregistered
    \item Recruit non-developer users to conduct beta testing
  \end{itemize}
\end{itemize}

\subsection{Updates since Torsten 0.82}
\begin{itemize}
  \item Torsten is now up to date with Stan version 2.16.0
  \item Add steady state solution for general compartment model, with some limitations
  \item Add ``mixed solver" functions
  \item Add algebraic solver
  \item Torsten automatically corrects ODE functors when the rates are non-zero. The code carefully distinguishes cases where the rates are fixed data or parameters. 
  \item Fix bug that prevented Jacobians from being accurately computed for \texttt{generalOdeModel\_*} when \texttt{biovar} was passed as parameters, causing the sampler to dissolve into a quasi-random walk.
  \item Fix bug that prevented users from using a print statement inside a function that specifies an ODE system.
  \item Fixed minor bugs and report issues.
\end{itemize}

\clearpage 

\section{Using Torsten}

The reader should have a basic understanding of how Stan works before reading this chapter. There are excellent resources online to get started with Stan (\url{http://mc-stan.org/documentation/}). 

In this section we go through the different functions Torsten adds to Stan. It will be helpful to apply these functions to a simple example. We have uploaded code and data on \url{https://github.com/metrumresearchgroup/example-models}.

\subsection{Example 1: Two Compartment Model} \ \\

We model drug absorption in a single patient and simulate plasma drug concentrations:
\begin{itemize}
  \item Multiple Doses: 1250 mg, every 12 hours, for a total of 15 doses
  \item PK: plasma concentrations of parent drug ($c$)
  \item PK measured at 0.083, 0.167, 0.25, 0.5, 0.75, 1, 1.5, 2, 4, 6, 8, 10 and 12 hours after 1st, 2nd, and 15th dose. In addition, the PK is measured every 12 hours throughout the trial.
\end{itemize}

The plasma concentration ($c$) are simulated according to the following equations:
\begin{eqnarray*}
\log\left(c\right) &\sim& N\left(\log\left(\widehat{c}\right),\sigma^2\right) \\
 \widehat{c} &=& f_{2cpt}\left(t, CL, Q, V_2, V_3, k_a\right) \\
  \left(CL, Q, V_2, V_3, ka\right) &=& 
	\left(5\ {\rm L/h}, 8\  {\rm L/h}, 20\  {\rm L},  70\ {\rm L}, 1.2\ {\rm h^{-1}} \right) \\
  \sigma^2 &=& 0.01
\end{eqnarray*}

and the drug concentration is given by $c = y_2/V_2$.

where the mass of drug in the central compartment ($y_2$) is obtained by solving the system of ordinary differential equations (ODEs):
\begin{eqnarray}
  \begin{aligned}
  y_1' &= -k_a y_1 \\
  y_2' &= k_a y_1 - \left(\frac{CL}{V_2} + \frac{Q}{V_2}\right) y_2 +  \frac{Q}{V_3}  y_3  \\ 
  y_3' &= \frac{Q}{V_2} y_2 - \frac{Q}{V_3} y_3
  \end{aligned}
  \label{eq:TwoCpt}
\end{eqnarray}

The data are generated using the R package \textit{mrgsolve} \cite{mrgsolve:2017}, see \texttt{TwoCptModelSimulation.R}. We use this example to demonstrate use of several functions in the Torsten library.

\subsection{Linear One and Two Compartment Model Function} \ \\

The one and two compartment model functions have the form:

\texttt{<model name>(time, amt, rate, ii, evid, cmt, addl, ss,\\
\phantom{<model name>} theta,  biovar, tlag)} \\

There is no need to skip a line, but we do so to distinguish between \textit{event} arguments and \textit{model} arguments.

The event arguments describe the event schedule of the clinical trial. \texttt{time}, \texttt{amt}, \texttt{rate},  and \texttt{ii} are arrays of real and \texttt{evid}, \texttt{cmt}, \texttt{addl}, and \texttt{ss} arrays of integers. All arrays have the same length, which corresponds to the number of events.

Next we have the model arguments: \texttt{theta} contains the ODE parameters, \texttt{biovar} the bioavailability fraction in each compartment (sometimes denoted as \textit{F}), and \texttt{tlag} the lag time in each compartment.  The model arguments may be either one or two dimensional arrays. If they are one dimensional arrays, the parameters are constant for all events. If they are two dimensional arrays then each row contains the parameters for the interval [\texttt{time[i-1], time[i]}]. The number of rows should equal the number of events. 

The options for \textit{model name} are:
\begin{itemize}
  \item PKModelOneCpt
  \item PKModelTwoCpt
\end{itemize}
which respectively correspond to the one and two compartment model with a first order absorption (figure~\ref{cptModels}). An array in \texttt{theta} is expected to contain parameters $CL$, $V_2$, and $ka$ for the one compartment case, and $CL$, $Q$, $V_2$, $V_3$, and $ka$ for the two compartments case, \underline{in this order}. Setting $ka$ to 0 eliminates the fist-order absoprtion. \texttt{biovar} contains the bioavailability fraction of each compartment (non-effective if set to 1) and \texttt{tlag} the lag time in each compartment (non-effective if set to 0).

\begin{figure}[htbp]
\includegraphics[width=3.5in,trim=0in 0in 0 0in]{graphics/cptModels.png}
\caption{One and two compartment models with first order absorption implemented in Torsten.}
\label{cptModels}
\end{figure}

\texttt{PKModelTwoCpt} can be used to fit example 1, see \texttt{TwoCptModel.stan}. We are interested in evaluating the ODE parameters, stored in \texttt{theta}. The bioavailability fraction and the lag times on the other hand are fixed, and we therefore declare \texttt{biovar} and \texttt{tlag} in the \textbf{transformed data} block. Three MCMC chains of 2000 iterations were simulated. The first 1000 iteration of each chain were discarded. Thus 1000 MCMC samples were used for the subsequent analyses.

\begin{figure}[htbp]
\begin{center}
\begin{small}
\begin{fmpage}{\textwidth - .75in}
\begin{lstlisting}[basicstyle=\footnotesize\ttfamily,mathescape=true,flexiblecolumns=true,frame=single,escapeinside=`']
`\bf{data}' {
  int<lower = 1> nt; `\textcolor{gray}{// number of events}'
  int<lower = 1> nObs; `\textcolor{gray}{// number of observation}'
  int<lower = 1> iObs[nObs]; `\textcolor{gray}{// index of observation}'
  int cmt[nt];
  int evid[nt];
  int addl[nt];
  int ss[nt];
  real amt[nt];
  real time[nt];
  real rate[nt];
  real ii[nt];
  
  vector<lower = 0>[nObs] cObs; `\textcolor{gray}{//  observed concentration (Dependent Variable)}'
}

`\bf{transformed data}' {
                                    $\vdots$
  biovar[1] = 1;
  biovar[2] = 1;
  biovar[3] = 1;
  
  tlag[1] = 0;
  tlag[2] = 0;
  tlag[3] = 0;                                    
                                    
                                     
}
                                    $\vdots$ 
`\bf{parameters}' {
  real<lower = 0> CL;
  real<lower = 0> Q;
  real<lower = 0> V2;
  real<lower = 0> V3;
  real<lower = 0> ka;
  real<lower = 0> sigma;
}

`\bf{transformed parameters}' {
                                    $\vdots$ 
  theta[1] = CL;
  theta[2] = Q;
  theta[3] = V2;
  theta[4] = V3;
  theta[5] = ka;

  x = `\textcolor{red}{PKModelTwoCpt}'(time, amt, rate, ii, evid, cmt, addl, ss, 
                          theta, biovar, tlag);

  cHat = col(x, 2) ./ V2; `\textcolor{gray}{//  get concentration in the central compartment}'
  
  cHatObs = cHat[iObs];  `\textcolor{gray}{// predictions for observed data records}'
 
 }
                                    $\vdots$ 
\end{lstlisting}
\end{fmpage}
\end{small}
\caption{Stan language for fitting a two compartment model using the \texttt{PKModelTwoCpt} function (abstract)}
\end{center}
\label{TwoCptCode}
\end{figure}

\textbf{Result.} The MCMC history plots (figure~\ref{TwoCptMCMC}) suggest that the 3 chains have converged to common distributions for all of the key model parameters. The  fit to the plasma concentration data (figure~\ref{TwoCptPredictions}) are in close agreement with the data, which is not surprising since the fitted model is identical to the one used to simulate the data. Similarly the parameter estimates summarized in Table 1 are consistent with the values used for simulation.

\begin{figure}[htbp]
\includegraphics[width=3.0in,trim=0in 0in 0 0in]{graphics/TwoCptModelPlots001.pdf}
\includegraphics[width=3.0in,trim=0in 0in 0 0in]{graphics/TwoCptModelPlots002.pdf}
\caption{{MCMC history plots for the parameters of a two compartment model with first order absorption (each color corresponds to a different chain)}}
\label{TwoCptMCMC}
\end{figure}

\begin{figure}[!htb]
\begin{center}
\includegraphics[width=3.5in,trim=0in 0in 0 0in]{graphics/TwoCptModelPlots003.pdf}
\caption{{Posterior Marginal Densities of the Model Parameters of a two compartment model with first order absorption (each color corresponds to a different chain)}}
\label{TwoCptDensity}
\end{center}
\end{figure}

\begin{figure}[!htb]
\begin{center}
\includegraphics[width=3.5in,trim=0in 0in 0 0in]{graphics/TwoCptModelPlots006.pdf}
\caption{{Predicted (posterior median and 90 \% credible intervals) and observed plasma drug concentrations of a two compartment model with first order absorption}}
\label{TwoCptPredictions}
\end{center}
\end{figure}

\begin{table}[!htb]
\centering
\caption{Summary of the MCMC simulations of the marginal posterior distributions of the model parameters}
\begin{tabular}{rrrrrrrrrrr}
  \hline
 & mean & se\_mean & sd & 2.5\% & 25\% & 50\% & 75\% & 97.5\% & n\_eff & Rhat \\ 
  \hline
CL & 4.82 & 0.002 & 0.0901 & 4.64 & 4.76 & 4.82 & 4.88 & 5.00 & 2464.73 & 1.00 \\ 
  Q & 7.54 & 0.016 & 0.58 & 6.43 & 7.15 & 7.54 & 7.92 & 8.69 & 1385.75 & 1.00 \\ 
  V2 & 21.14 & 0.069 & 2.45 & 16.37 & 19.44 & 21.19 & 22.78 & 25.89 & 1245.64 & 1.00 \\ 
  V3 & 76.35 & 0.110 & 5.35 & 65.98 & 72.75 & 76.26 & 79.83 & 87.30 & 2379.15 & 1.00 \\ 
  ka & 1.23 & 0.005 & 0.169 & 0.923 & 1.12 & 1.23 & 1.35 & 1.58 & 1295.01 & 1.00 \\
  sigma & 0.108 &  0.000 & 0.012 & 0.0887 & 0.0999 & 0.107 & 0.115 & 0.135 & 1973.97 & 1.00 \\
   \hline
\end{tabular}
\end{table}

\clearpage

\subsection{General Linear ODE Model Function} \ \\

A general linear ODE model refers to a model that may be described in terms of a system of first order linear differential equations with (piecewise) constant coefficients, i.e., a differential equation of the form: \\
$$ y^\prime\left(t\right) = Ky\left(t\right) $$ \\
where $K$ is a matrix. For example $K$ for a two compartment model (equation~\ref{eq:TwoCpt}) with first order absorption is: \\
$$   K = \left[\begin{array}{ccc}
	-k_a & 0 & 0 \\
	k_a & -\left(k_{10} + k_{12}\right) & k_{21} \\
	0 & k_{12} & -k_{21}
	\end{array}\right] $$ \\ \ \\
where $k_{10} = CL / V_2 $, $ k_{12} = Q / V_2 $, and $k_{21} = Q / V_3 $.

The linear ODE model function has the form:

\texttt{linOdeModel(time, amt, rate, ii, evid, cmt, addl, ss,\\
\phantom{linOdeModel} system, biovar, tlag)}

\texttt{system} can be:
\begin{itemize}
  \item the matrix \texttt{K}, if the constant rate matrix is the same for all events.
  \item an array of constant rate matrices. The length of the array is the number of events and each element corresponds to the matrix at the interval [\texttt{time[i-1], time[i]}].
\end{itemize}
\texttt{system} contains all the ODE parameters, so we no longer need \texttt{theta}.

\clearpage

\begin{figure}[!htb]
\caption{Stan language for fitting a two compartment model using the \texttt{linOdeModel} function (abstract)}
\begin{center}
\begin{small}
\begin{fmpage}{\textwidth - .75in}
\begin{lstlisting}[basicstyle=\footnotesize\tiny\ttfamily,mathescape=true,flexiblecolumns=true,frame=single,escapeinside=`']
`\bf{transformed parameters}' {
  `\textcolor{red}{matrix[3, 3] K;}'
  real k10 = CL / V2;
  real k12 = Q / V2;
  real k21 = Q / V3;
  vector<lower = 0>[nTheta] theta[1];
  vector<lower = 0>[nt] cHat;
  vector<lower = 0>[nObs] cHatObs;
  matrix<lower = 0>[nt, 3] x;
 
  `\textcolor{red}{K = rep\_matrix(0, 3, 3);}'

  `\textcolor{red}{K[1, 1] = -ka;}'  
  `\textcolor{red}{K[2, 1] = ka;}' 
  `\textcolor{red}{K[2, 2] = -(k10 + k12);}' 
  `\textcolor{red}{K[2, 3] = k21;}' 
  `\textcolor{red}{K[3, 2] = k12;}' 
  `\textcolor{red}{K[3, 3] = -k21;}'

  x = `\textcolor{red}{linOdeModel}'(time, amt, rate, ii, evid, cmt, addl, ss,
                       K, biovar, tlag);

  cHat = col(x, 2) ./ V1;
  
  cHatObs = cHat[iObs];  `\textcolor{gray}{\# predictions for observed data records}'

}

`\bf{model}'{
  logCObs ~ normal(log(cHatObs), sigma);
}
\end{lstlisting}
\end{fmpage}
\end{small}
\end{center}
\label{LinTwoCptCode}
\end{figure}

\subsection{General ODE Model Function} \ \\

Torsten may be used to fit models described by a system of first-order ODEs, i.e., differential equations of the form:
$$ y^\prime(t) = f(t, y(t)) $$

In the case where the rate vector $R$ is non-zero, this equation becomes:
$$ y^\prime(t) = f(t, y(t)) + R $$
  
The general ODE model functions have the form: \ \\

\texttt{<model\_name>(ODE\_system, nCmt, \\
\phantom{<model\_name>} time, amt, rate, ii, evid, cmt, addl, ss, \\
\phantom{<model\_name>} theta, biovar, tlag, \\                              
\phantom{<model\_name>} rel\_tol, abs\_tol, max\_step)}

\ \\
where \texttt{ODE\_system} specifies $f(t, y(t))$, which the user defines inside the \textbf{functions} block (see section 19.2 of the Stan reference manual for details and figure~\ref{GenTwoCptModelCode} for an example). The user does NOT include the rates in their definition of $f$. Torsten automatically corrects the derivatives when the rates are non-zero.

\texttt{nCmt} is the number of compartments (or, equivalently, the number of ODEs) in the model. \texttt{rel\_tol}, \texttt{abs\_tol}, and \texttt{max\_step} are tuning parameters for the ODE integrator: respectively the relative tolerance, the absolute tolerance, and the maximum number of steps.

The options for \texttt{model\_name} are:
\begin{itemize}
  \item generalOdeModel\_rk45
  \item generalOdeModel\_bdf
\end{itemize}

They respectively call the built-in Runge-Kutta 4th/5th order (rk45) integrator, recommended for non-stiff ODEs, and the Backward Differentiation (BDF) integrator, recommended for stiff ODEs. Which value to use for the tuning parameters depends on the integrator and the specifics of the ODE system. Reducing the tolerance parameters and increasing the number of steps make for a more robust integrator but can significantly slow down the algorithm. The following can be used as a starting point:  \mbox{\texttt{rel\_tol = 1e-6}}, \mbox{\texttt{abs\_tol = 1e-6}} and \mbox{\texttt{max\_step = 1e+6}} for the rk45 integrator and \mbox{\texttt{rel\_tol = 1e-10}}, \mbox{\texttt{abs\_tol = 1e-10}} and \mbox{\texttt{max\_step = 1e+8}} for the bdf integrator\footnote{These are the default tuning parameters for integrate\_ode\_rk45() and integrate\_ode\_bdf().  Torsten functions do not have a default values for these parameters. The user must explicitly pass the tuning parameters to generalOdeModel\_*().}. Users should be prepared to adjust these values. For additional information, see Stan's reference manual (section 19).

A few notable restrictions apply to \texttt{generalOdeModel\_*}:
\begin{itemize}
  \item \texttt{rate} and \texttt{time} cannot be passed as parameters.
  \item In the case of a multiple truncated infusion rate dosing regimen:
  \begin{itemize}
    \item The bioavailability (\texttt{biovar}) and the amount (\texttt{amt}) cannot be passed as parameters.
  \end{itemize}
\end{itemize}

These restrictions apply to \texttt{mixOde\#Cpt\_*} functions, discussed in the next section.

\clearpage

\begin{figure}
\caption{Stan language for fitting a two compartment model using the \texttt{generalOdeModel\_rk45} function (abstract)}
\begin{center}
\begin{small}
\begin{fmpage}{\textwidth - .75in}
\begin{lstlisting}[basicstyle=\footnotesize\ttfamily,mathescape=true,flexiblecolumns=true,frame=single,escapeinside=`']
`\bf{functions}'{
  # define ODE system for two compartment model
  real[] `\textcolor{red}{twoCptModelODE}'(real t,
			       real[] y,
			       real[] theta,
			       real[] dummy_real,
			       int[] dummy_int){
    real Q = theta[1];
    real CL = theta[2];
    real V2 = theta[3];
    real V3 = theta[4];
    real ka = theta[5];
    real k12 = Q / V2;
    real k21 = Q / V3;
    real k10 = CL / V2;
    real y[3]; 

    dydt[1] = -ka * y[1];
    dydt[2] = ka * y[1] - (k10 + k12)*y[2] + k21*y[3];
    dydy[3] = k12 * y[2] - k21 * y[3];

    return dydt;
  }
}
                                    $\vdots$
`\bf{transformed parameters}' {
                                    $\vdots$
  theta[1] = CL;
  theta[2] = Q;
  theta[3] = V1;
  theta[4] = V2;
  theta[5] = ka;

  x = `\textcolor{red}{generalCptModel\_rk45}'(`\textcolor{red}{twoCptModelODE}', 3,
                                  time, amt, rate, ii, evid, cmt, addl, ss,
                                  theta, biovar, tlag, 
                                  1e-8, 1e-8, 1e8);
                                    $\vdots$
\end{lstlisting}
\end{fmpage}
\end{small}
\end{center}
\label{GenTwoCptModelCode}
\end{figure}


\subsection{Mixed ODE Model Function} \ \\

In certain cases, an ODE system can be divided in two subsystems:

\begin{eqnarray*}
  y_1^\prime &=& f_1(t, y_1) \\
  y_2^\prime &=& f_2(t, y_1, y_2)
\end{eqnarray*} 

where $y_1$, $y_2$, $f_1$, and $f_2$ are vector-valued functions, and  $y_1^\prime$ is independent of $y_2$. This structure arises in PK/PD models, where $y_1$ describes a forcing PK function and $y_2$ the PD effects. If $y_1$ has an analytical solution, we can construct a \textit{mixed solver}, which analytically solves $y_1$ and numerically integrates $y_2$. This approach leads to an appreciable gain in computational efficiency. In the example of a Friberg-Karlsson semi-mechanistic model \cite{2364}, we observe an average speedup of $\sim 47 \pm 18 \%$ when using the mix solver in lieu of the numerical integrator \cite{Margossian:2017b}.

Torsten supports the mixed solver for cases where $y_1$ solves the ODEs for a One or Two Compartment model with a first-order absorption.

The mix ODE model functions have the form:

\texttt{<model\_name>(reduced\_ODE\_system, nOde, \\
\phantom{<model\_name>} time, amt, rate, ii, evid, cmt, addl, ss, \\
\phantom{<model\_name>} theta, biovar, tlag, \\                              
\phantom{<model\_name>} rel\_tol, abs\_tol, max\_step)}

where \texttt{reduced\_ODE\_system} specifies the system we  numerically solve ($y_2$ in the above discussion, also called the \textit{reduced system}) and \texttt{nOde} the number of equations in the \underline{reduced} system. The function that defines a reduced system has an almost identical signature to that used for a full system, but takes one additional argument: $y_1$, the PK states, i.e. solution to the PK ODEs (figure~\ref{reducedODESystem}).

\begin{figure}[htbp]
\caption{Stan language for defining a reduced ODE system}
\begin{center}
\begin{small}
\begin{fmpage}{\textwidth - .75in}
\begin{lstlisting}[basicstyle=\footnotesize\ttfamily,mathescape=true,flexiblecolumns=true,frame=single,escapeinside=`']
`\bf{functions}'{
  real[] reducedODE(real t,  // time
			  real[] y,  // reduced state
			  `\textcolor{red}{real[] y1,  // PK states}'
			  real[] theta,  // parameters
			  real[] x_r,  // data (real)
			  int[] x_int) {  // data (integer)	        
                                    $\vdots$			       
  }
}
\end{lstlisting}
\end{fmpage}
\end{small}
\end{center}
\label{reducedODESystem}
\end{figure}

 Again, the user does not specify the rates. Torsten automatically corrects the derivatives for non-zero rates.

The options for \texttt{modelName} are:
\begin{itemize}
  \item mixOde1CptModel\_rk45
  \item mixOde1CptModel\_bdf
  \item mixOde2CptModel\_rk45
  \item mixOde2CptModel\_bdf
\end{itemize}

These four functions correspond to all the permutations we can obtain when using a forcing One or Two Compartment function, and the Runge-Kutta 4th/5th order (rk45) or Backward Differentiation (BDF) integration method. The mixed ODE functions can be used to compute the steady state solutions supported by the general ODE model functions.

Restrictions regarding which arguments may be passed as parameters for \texttt{generalOdeModel\_*} also apply to \texttt{mixOde\#CptModel\_*}.

We cannot apply the mixed solver to the Two Compartment example we have been using so far. Instead, we will consider the model which motivated the implementation of the method in the first place.

\subsection{Example 2: Friberg-Karlsson Semi-Mechanistic Model \cite{2364}} \ \\

In this second example, we add to our two Compartment model a PD effect, described by a system of nonlinear ODEs.

Neutropenia is observed in patients receiving an ME-2 drug. Our goal is to model the relation between neutrophil counts and drug exposure. Using a feedback mechanism, the body maintains the number of neutrophils at a baseline value (figure~\ref{FK}). While in the patient's blood, the drug impedes the production of neutrophils. As a result, the neutrophil count goes down. After  the drug clears out, the feedback mechanism kicks in and brings the neutrophil count back to baseline.

{\bf Friberg-Karlsson Model for drug-induced myelosuppression ($ANC$)}

\begin{eqnarray*}
  \log(ANC_i) &\sim& N(\log(Circ), \sigma^2_{ANC})  \\
  Circ &=& f_{FK}(MTT, Circ_{0}, \alpha, \gamma, c)  \\
  (MTT, Circ_{0}, \alpha, \gamma, ktr) &=& (125, 5.0, 3 \times 10^{-4}, 0.17) \\
  \sigma^2_{ANC} &=& 0.001
\end{eqnarray*}

where $c$ is the drug concentration in the blood we get from the Two Compartment model, and $Circ$ is obtained by solving the following system of nonlinear ODEs:

\begin{eqnarray}
  \begin{aligned}
   y_\mathrm{prol}' &= k_\mathrm{prol} y_\mathrm{prol} (1 - E_\mathrm{drug})\left(\frac{Circ_0}{y_\mathrm{circ}}\right)^\gamma - k_\mathrm{tr}y_\mathrm{prol} \\
   y_\mathrm{trans1}' &= k_\mathrm{tr} y_\mathrm{prol} - k_\mathrm{tr} y_\mathrm{trans1} \\
   y_\mathrm{trans2}' &= k_\mathrm{tr} y_\mathrm{trans1} - k_\mathrm{tr} y_\mathrm{trans2}  \\
   y_\mathrm{trans3}' &= k_\mathrm{tr} y_\mathrm{trans2} - k_\mathrm{tr} y_\mathrm{trans3}  \\
   y_\mathrm{circ}' &= k_\mathrm{tr} y_\mathrm{trans3} - k_\mathrm{tr} y_\mathrm{circ}
   \end{aligned}
   \label{eq:FK}
\end{eqnarray}

where $E_{drug}  = \alpha c$.

The ODEs specifying the Two Compartment Model (equation~\ref{eq:TwoCpt}) do not depend on the PD ODEs (equation~\ref{eq:FK}) and can be solved analytically by Torsten. We therefore specify our model using a mixed solver function. We do not expect our system to be stiff and use the Runge-Kutta 4th/5th order integrator.


\begin{figure}[htbp]
\includegraphics[width=4.5in,trim=0in 0in 0 0in]{graphics/neutrophilModel.jpg}
\caption{Friberg-Karlsson semi-mechanistic Model \cite{2364}}
\label{FK}
\end{figure}

\begin{figure}
\caption{Stan language to define a reduced ODE system}
\begin{center}
\begin{small}
\begin{fmpage}{\textwidth - .75in}
\begin{lstlisting}[basicstyle=\footnotesize\ttfamily,mathescape=true,flexiblecolumns=true,frame=single,escapeinside=`']
`\bf{functions}'{
  # define reduced ODE system for two compartment model
  real[] `\textcolor{red}{FK\_ODE}'(real t,
		    real[] y,
		    real[] y_pk,
		    real[] theta,
		    real[] dummy_real,
		    int[] dummy_int){
    real V2 = theta[3];

    ## PK variables
    real VC = parms[3];

    ## PD variables
    real MTT = parms[6];
    real circ0 = parms[7];
    real alpha = parms[8];
    real gamma = parms[9];
    real ktr = 4 / MTT;
    real prol = y[1] + circ0;
    real transit1 = y[2] + circ0;
    real transit2 = y[3] + circ0;
    real transit3 = y[4] + circ0;
    real circ = fmax(machine_precision(), y[5] + circ0);
    real conc = y_pk[2] / VC;
    real Edrug = alpha * conc;
    real dydt[5];

    conc = y_pk[2] / VC;
    Edrug = alpha * conc;

    dydt[1] = ktr * prol * ((1 - Edrug) * ((circ0 / circ)^gamma) - 1);
    dydt[2] = ktr * (prol - transit1);
    dydt[3] = ktr * (transit1 - transit2);
    dydt[4] = ktr * (transit2 - transit3);
    dydt[5] = ktr * (transit3 - circ);

    return dydt;
  }
}
\end{lstlisting}
\end{fmpage}
\end{small}
\end{center}
\label{FK_reduced}
\end{figure}

\begin{figure}
\caption{Stan language for fitting a Friberg-Karlsson model using \texttt{mixOde2CptModel\_rk45}}
\begin{center}
\begin{small}
\begin{fmpage}{\textwidth - .75in}
\begin{lstlisting}[basicstyle=\footnotesize\ttfamily,mathescape=true,flexiblecolumns=true,frame=single,escapeinside=`']
functions {
  real[] `\textcolor{red}{FK\_ODE}' {
                  $\vdots$	
  }
}

transformed date {
int `\textcolor{red}{nOde}' = 5;
                  $\vdots$
}

transformed parameters {
  vector[nt] cHat;
  vector[nObsPK] cHatObs;
  vector[nt] neutHat;
  vector<lower = 0>[nObsPD] neutHatObs;
  real theta[nParms];  # ODE parameters
  matrix[nt, nCmt] x;
  
  theta[1] = CL;
  theta[2] = Q;
  theta[3] = VC;
  theta[4] = VP;
  theta[5] = ka;
  theta[6] = mtt;
  theta[7] = circ0;
  theta[8] = alpha;
  theta[9] = gamma;

  x = `\textcolor{red}{mixOde2CptModel\_rk45}'(`\textcolor{red}{FK\_ODE}', `\textcolor{red}{nOde}',
                                   time, amt, rate, ii, evid, cmt, addl, ss,
                                   theta, biovar, tlag,
                                   1e-6, 1e-6, 1e+6);

  cHat = x[ , 2] / VC;
  neutHat = x[ , 8] + circ0;

  cHatObs = cHat[iObsPK];
  neutHatObs = neutHat[iObsPD];
}
\end{lstlisting}
\end{fmpage}
\end{small}
\end{center}
\label{FK_mix2}
\end{figure}


\begin{table}[!htb] %[htdp]
\caption{Summary: Arguments of Torsten functions.}
\begin{center}
\begin{minipage}{\textwidth - 1in}
\begin{tabular}{p{1.5in}cp{1.5in}p{1.5in}} 
\hline\hline
 & function & argument & parameters \\
model & name & names & in {\tt theta}\\ 
\hline
{\raggedright one compartment\\ model with first order\\ absorption} 
   & {\tt PKModelOneCpt} &  
	{\tt time}, {\tt amt}, {\tt rate}, {\tt ii}, {\tt evid}, {\tt cmt}, {\tt addl}, {\tt ss}, {\tt theta}, {\tt biovar}, {\tt tlag} &
	$CL$, $V_2$, $k_a$ \\
\hline
{\raggedright two compartment\\ model with first order\\ absorption}
   & {\tt PKModelTwoCpt} &  
	{\tt time}, {\tt amt}, {\tt rate}, {\tt ii}, {\tt evid}, {\tt cmt}, {\tt addl}, {\tt ss}, {\tt theta}, {\tt biovar}, {\tt tlag} &
	$CL$, $Q$, $V_2$, $V_3$, $k_a$ \\ 
\hline
{\raggedright general linear \\ compartment model} & {\tt linOdeModel} &  
	{\tt time}, {\tt amt}, {\tt rate}, {\tt ii}, {\tt evid}, {\tt cmt}, {\tt addl}, {\tt ss}, {\tt system}, {\tt biovar}, {\tt tlag} &
	NA: pass in constant rate matrix instead of {\tt theta} \\
\hline
{\raggedright general compartment \\ models} & {\tt genOdeModel\_*} &  
	{\tt ODE\_system}, {\tt nCmt}, {\tt time}, {\tt amt}, {\tt rate}, {\tt ii}, {\tt evid},
        {\tt cmt}, {\tt addl}, {\tt ss}, {\tt theta}, {\tt biovar}, {\tt tlag}, {\tt rel\_tol}, {\tt abs\_tol}, {\tt max\_num\_steps}  &
	Parameters that get passed to ODE system  \\
\hline
{\raggedright mix 1 compartment \\ model} & {\tt mixOde1Cpt\_*} &
       {\tt reduced\_ODE\_system}, {\tt nOde}, {\tt time}, {\tt amt}, {\tt rate}, {\tt ii}, {\tt evid},
       {\tt cmt}, {\tt addl}, {\tt ss}, {\tt theta}, {\tt biovar}, {\tt tlag}, {\tt rel\_tol}, {\tt abs\_tol}, {\tt max\_num\_steps} &
       $CL$, $V_2$, $k_a$, followed by the parameters that get passed to the reduced ODE system \\
\hline
{\raggedright mix 2 compartment \\ model} & {\tt mixOde2Cpt\_*} &
       {\tt reduced\_ODE\_system}, {\tt nOde}, {\tt time}, {\tt amt}, {\tt rate}, {\tt ii}, {\tt evid},
       {\tt cmt}, {\tt addl}, {\tt ss}, {\tt theta}, {\tt biovar}, {\tt tlag}, {\tt rel\_tol}, {\tt abs\_tol}, {\tt max\_num\_steps} &
       $CL$, $Q$, $V_2$, $V_3$, $k_a$, followed by the parameters that get passed to the reduced ODE system  
\end{tabular}
\end{minipage}
\end{center}
\label{precompiledModels}
\end{table}
% Table \ref{precompiledModels} contains a summary of arguments for Torsten functions.

\clearpage

\section{Additional Examples}

Code for examples can be found on GitHub: \url{https://github.com/metrumresearchgroup/example-models}.

All the files to run a model are stored under the directory that bears the model's name. There are four files per example:
\begin{itemize}
  \item \texttt{<model name>.stan}
  \item \texttt{<model name>.data.R}
  \item \texttt{<model name>.init.R}
  \item \texttt{<model name>Simulation.R}
\end{itemize}

\texttt{data.R} contains the data we fit the model to and \texttt{init.R} an initial estimate of the parameters. These two files are generated using \texttt{Simulation.R}. The \texttt{R} folder contains R scripts to compile and run the models, as well as code to output diagnostic plots and statistics.

\subsection {Example 3: Effect Compartment Population Model} \ \\ \ \\
Let us expand example 1 to a population model fitted to the combined data from phase I and phase IIa studies. The parameters exhibit inter-individual variations (IIV), due to both random effects and to the patients' body weight, treated as a covariate and denoted $bw$:

\subsubsection*{Population Model for Plasma Drug Concentration ($c$)}
\begin{eqnarray*}
 \log\left(c_{ij}\right) &\sim& N\left(\log\left(\widehat{c}_{ij}\right),\sigma^2\right) \\
 \widehat{c}_{ij} &=& f_{2cpt}\left(t_{ij},D_j,\tau_j,CL_j,Q_j,V_{1j},V_{2j},k_{aj}\right) \\
 \log\left(CL_j,Q_j,V_{ssj},k_{aj}\right) &\sim&
   \lefteqn{N\left(\log\left(\widehat{CL}\left(\frac{bw_j}{70}\right)^{0.75},\widehat{Q}\left(\frac{bw_j}{70}\right)^{0.75},
	\widehat{V}_{ss}\left(\frac{bw_j}{70}\right),\widehat{k}_a\right),\Omega\right)} \\
 V_{1j} &=& f_{V_1}V_{ssj} \ \ \ \ \ \ V_{2j} = \left(1 - f_{V_1}\right)V_{ssj} \\
 \left(\widehat{CL},\widehat{Q},\widehat{V}_{ss},\widehat{k}_a, f_{V_1}\right) &=& 
	\left(10\ {\rm L/h},15\  {\rm L/h},140\  {\rm L},2\ {\rm h^{-1}}, 0.25 \right) \\
\Omega &=& \left(\begin{array}{cccc} 0.25^2 & 0 & 0 & 0 \\ 0 & 0.25^2 & 0 & 0 \\
0 & 0 & 0.25^2 & 0 \\ 0 & 0 & 0 & 0.25^2  \end{array}\right), \ \ \ \sigma = 0.1 \\
\end{eqnarray*}

Furthermore we add a fourth compartment in which we measure a PD effect (figure~\ref{effCptModel}).

\begin{figure}[htbp]
\includegraphics[width=3.5in,trim=0in 0in 0 0in]{graphics/effCptModel.png}
\caption{Effect Compartment Model}
\label{effCptModel}
\end{figure}

\subsubsection*{Effect Compartment Model for PD response ($R$)}
\begin{eqnarray*}
R_{ij} &\sim& N\left(\widehat{R}_{ij},\sigma_{R}^2\right) \\
\widehat{R}_{ij} &=& \frac{E_{max}c_{eij}}{EC_{50j} + c_{eij}} \\
c_{e\cdot j}^\prime &=& k_{e0j}\left(c_{\cdot j} - c_{e\cdot j}\right) \\
\log\left(EC_{50j}, k_{e0j}\right) &\sim& N\left(\log\left(\widehat{EC}_{50}, \widehat{k}_{e0}\right),\Omega_R\right) \\
\left(E_{max}, \widehat{EC}_{50},\widehat{k}_{e0}\right) &=& \left(100, 100.7, 1\right) \\
\Omega_R &=& \left(\begin{array}{cc} 0.2^2 & 0 \\ 0 & 0.25^2  \end{array}\right), \ \ \ \sigma_R = 10
\end{eqnarray*}

The PK and the PD data are simulated using the following treatment.
\begin{itemize}
  \item Phase I study
  \begin{itemize}
    \item Single dose and multiple doses
    \item Parallel dose escalation design
    \item 25 subjects per dose
    \item Single doses: 1.25, 5, 10, 20, and 40 mg 
    \item PK: plasma concentration of parent drug ($c$)
    \item PD response: Emax function of effect compartment concentration ($R$)
    \item PK and PD measured at 0.083, 0.167, 0.25, 0.5, 0.75, 1, 2, 3, 4, 6, 8, 12, 18, and 24 hours
  \end{itemize}
  \item Phase IIa trial in patients
  \begin{itemize}
    \item 100 subjects
    \item Multiple doses: 20 mg
    \item sparse PK and PD data (3-6 samples per patient)
  \end{itemize}
\end{itemize}

The model is simultaneously fitted to the PK and the PD data. For this effect compartment model, we construct a constant rate matrix and use \texttt{linOdeModel}. Correct use of Torsten requires the user pass the entire event history (observation and dosing events) for an individual to the function. Thus the Stan model shows the call to \texttt{linOdeModel} within a loop over the individual subjects rather than over the individual observations.

\begin{figure}
\caption{Stan language for fitting an effect compartment model using \texttt{linOdeModel} (abstract)}
\begin{small} 
\begin{center}
\begin{fmpage}{\textwidth - .75in}
\begin{lstlisting}[basicstyle=\tiny\ttfamily,mathescape=true,flexiblecolumns=true,frame=single,escapeinside=`']
transformed parameters {
  for(j in 1:nSubjects){
                             $\vdots$
  Omega = quad_form_diag(rho, omega);

  for(j in 1:nSubjects){
    CL[j] = exp(logtheta[j, 1]) * (weight[j] / 70)^0.75;
    Q[j] = exp(logtheta[j, 2]) * (weight[j] / 70)^0.75;
    V1[j] = exp(logtheta[j, 3]) * weight[j] / 70;
    V2[j] = exp(logtheta[j, 4]) * weight[j] / 70;
    ka[j] = exp(logtheta[j, 5]);
    ke0[j] = exp(logKe0[j]);
    EC50[j] = exp(logEC50[j]);

    k10 = CL[j] / V1[j];
    k12 = Q[j] / V1[j];
    k21 = Q[j] / V2[j];                       
    ke0[j] = exp(logKe0[j]);
    EC50[j] = exp(logEC50[j]);

    K = rep_matrix(0, 4, 4);
    
    K[1, 1] = -ka[j];
    K[2, 1] = ka[j];
    K[2, 2] = -(k10 + k12);
    K[2, 3] = k21;
    K[3, 2] = k12;
    K[3, 3] = -k21;
    K[4, 2] = ke0[j];
    K[4, 4] = -ke0[j];
           
    x[start[j]:end[j],] = `\textcolor{red}{linOdeModel}'(time[start[j]:end[j]], 
                                                 amt[start[j]:end[j]], 
                                                 rate[start[j]:end[j]],
                                                 ii[start[j]:end[j]], 
                                                 evid[start[j]:end[j]],
                                                 cmt[start[j]:end[j]], 
                                                 addl[start[j]:end[j]], 
                                                 ss[start[j]:end[j]], 
                                                 K, biovar, tlag);

    cHat[start[j]:end[j]] = 1000 * x[start[j]:end[j], 2] ./ V1[j];
    ceHat[start[j]:end[j]] = 1000 * x[start[j]:end[j], 4] ./ V1[j];
    respHat[start[j]:end[j]] = 100 * ceHat[start[j]:end[j]] ./ 
       (EC50[j] + ceHat[start[j]:end[j]]);
  }

  cHatObs = cHat[iObs];
  respHatObs = respHat[iObs];
}
                             $\vdots$  
} 
\end{lstlisting}
\end{fmpage}
\end{center}
\end{small}
\label{effCptModelCode}
\end{figure}

\subsubsection*{Results} We use the same diagnosis tools as for the previous example. The MCMC history plots (figure \ref{effCptModelMCMC}) suggest the 4 chains have converged to common distributions. We note some minor auto-correlations for $lp\_$ (the log posterior) and for IIV parameters: specifically $\Omega_{ke\_0}$ and $\rho$. The correlation matrix $\rho$ does not explicitly appear in the model, but it is used to construct $\Omega$, which parametrizes the PK IIV. The fits to the plasma concentration  (figure~\ref{effCptModelPredictionsPK}) are in close agreement with the data, notably for the sparse data case (phase IIa study). The fits to the PD data (figure~\ref{effCptModelPredictionsPD}) look good, though the data is more noisy. The model reflects the noise by producing larger credible intervals. The estimated values of the parameters are consistent with the values used to simulate the data.

\begin{table}[!htb]
\centering
\caption{Summary of the MCMC simulations of the marginal posterior distributions of the model parameters for example 2}
\begin{tabular}{rrrrrrrrrrr}
  \hline
 & mean & se\_mean & sd & 2.5\% & 25\% & 50\% & 75\% & 97.5\% & n\_eff & Rhat \\ 
  \hline
CLHat & 10.523 & 0.003 & 0.201 & 9.712 & 9.958 & 10.096 & 10.231 & 10.483 & 4000.000 & 0.999 \\
QHat & 14.867 & 0.014 & 0.357 & 14.182 & 14.620 & 14.862 & 15.106 & 15.563 & 678.208 & 1.007 \\
V1Hat & 34.188 & 0.067 & 1.089 & 31.940 & 33.494 & 34.214 & 34.918 & 36.251 & 267.748 & 1.016 \\
V2Hat & 103.562 & 0.076 & 2.925 & 98.031 & 101.600 & 103.455 & 105.472 & 109.583 & 488.296 & 1.001 \\
kaHat & 1.930 & 0.004 & 0.077 & 1.771 & 1.880 & 1.933 & 1.982 & 2.076 & 334.888 & 1.014 \\
ke0Hat & 1.050 & 0.001 & 0.044 & 0.967 & 1.020 & 1.051 & 1.078 & 1.137 & 164.741 & 1.000 \\
EC50Hat & 104.337 & 0.040 & 2.100 & 100.169 & 102.909 & 104.345 & 105.768 & 108.351 & 744.041 & 1.000 \\
sigma & 0.099 & 0.000 & 0.002 & 0.095 & 0.097 & 0.099 & 0.100 & 0.103 & 906.342 & 1.002 \\
sigmaResp & 10.156 & 0.003 & 0.197 & 9.779 & 10.023 & 10.154 & 10.286 & 10.552 & 4000.000 & 1.000 \\
omega[1] & 0.270 & 0.000 & 0.016 & 0.241 & 0.259 & 0.269 & 0.280 & 0.302 & 4000.000 & 1.001 \\
omega[2] & 0.231 & 0.001 & 0.021 & 0.192 & 0.217 & 0.230 & 0.245 & 0.275 & 531.512 & 1.006 \\
omega[3] & 0.219 & 0.002 & 0.031 & 0.158 & 0.199 & 0.218 & 0.238 & 0.281 & 158.198 & 1.017 \\
omega[4] & 0.267 & 0.001 & 0.026 & 0.218 & 0.249 & 0.266 & 0.284 & 0.319 & 684.870 & 1.001 \\
omega[5] & 0.285 & 0.002 & 0.037 & 0.214 & 0.259 & 0.284 & 0.309 & 0.361 & 284.545 & 1.009 \\
omegaKe0 & 0.271 & 0.003 & 0.047 & 0.183 & 0.239 & 0.271 & 0.303 & 0.363 & 217.350 & 1.007 \\
omegaEC50 & 0.213 & 0.001 & 0.021 & 0.174 & 0.199 & 0.213 & 0.227 & 0.255 & 190.193 & 1.000 \\
  \hline
\end{tabular}
\end{table}

\clearpage

\begin{figure}[!htb]
\includegraphics[width=3.0in,trim=0in 0in 0 0in]{graphics/effCptModelTorsten_0.82/effCptPlots001.pdf}
\includegraphics[width=3.0in,trim=0in 0in 0 0in]{graphics/effCptModelTorsten_0.82/effCptPlots002.pdf}
\includegraphics[width=3.0in,trim=0in 0in 0 0in]{graphics/effCptModelTorsten_0.82/effCptPlots003.pdf}
\includegraphics[width=3.0in,trim=0in 0in 0 0in]{graphics/effCptModelTorsten_0.82/effCptPlots004.pdf}
\includegraphics[width=3.0in,trim=0in 0in 0 0in]{graphics/effCptModelTorsten_0.82/effCptPlots005.pdf}
\caption{{MCMC history plots for the parameters of an Effect Compartment Model (each color corresponds to a different chain) for example 2}}
\label{effCptModelMCMC}
\end{figure}

\begin{figure}[!htb]
\includegraphics[width=3.0in,trim=0in 0in 0 0in]{graphics/effCptModelTorsten_0.82/effCptPlots006.pdf}
\includegraphics[width=3.0in,trim=0in 0in 0 0in]{graphics/effCptModelTorsten_0.82/effCptPlots007.pdf}
\caption{{Posterior Marginal Densities of the Model Parameters of an Effect Compartment Model (each color corresponds to a different chain) for example 2}}
\label{effCptModelDens}
\end{figure}

\begin{figure}[htbp]
\includegraphics[width=1.5in,trim=0in 0in 0 0in]{graphics/effCptModelTorsten_0.82/effCptPlots011.pdf}
\includegraphics[width=1.5in,trim=0in 0in 0 0in]{graphics/effCptModelTorsten_0.82/effCptPlots012.pdf}
\includegraphics[width=1.5in,trim=0in 0in 0 0in]{graphics/effCptModelTorsten_0.82/effCptPlots013.pdf}
\includegraphics[width=1.5in,trim=0in 0in 0 0in]{graphics/effCptModelTorsten_0.82/effCptPlots014.pdf}
\includegraphics[width=1.5in,trim=0in 0in 0 0in]{graphics/effCptModelTorsten_0.82/effCptPlots019.pdf}
\includegraphics[width=1.5in,trim=0in 0in 0 0in]{graphics/effCptModelTorsten_0.82/effCptPlots020.pdf}
\includegraphics[width=1.5in,trim=0in 0in 0 0in]{graphics/effCptModelTorsten_0.82/effCptPlots021.pdf}
\includegraphics[width=1.5in,trim=0in 0in 0 0in]{graphics/effCptModelTorsten_0.82/effCptPlots022.pdf}
\caption{{Predicted (posterior median and 90 \% credible intervals) and observed plasma drug concentrations for example 2 for an Effect Compartment Model}}
\label{effCptModelPredictionsPK}
\end{figure}

\begin{figure}[htbp]
\includegraphics[width=1.5in,trim=0in 0in 0 0in]{graphics/effCptModelTorsten_0.82/effCptPlots023.pdf}
\includegraphics[width=1.5in,trim=0in 0in 0 0in]{graphics/effCptModelTorsten_0.82/effCptPlots024.pdf}
\includegraphics[width=1.5in,trim=0in 0in 0 0in]{graphics/effCptModelTorsten_0.82/effCptPlots025.pdf}
\includegraphics[width=1.5in,trim=0in 0in 0 0in]{graphics/effCptModelTorsten_0.82/effCptPlots026.pdf}
\includegraphics[width=1.5in,trim=0in 0in 0 0in]{graphics/effCptModelTorsten_0.82/effCptPlots027.pdf}
\includegraphics[width=1.5in,trim=0in 0in 0 0in]{graphics/effCptModelTorsten_0.82/effCptPlots028.pdf}
\includegraphics[width=1.5in,trim=0in 0in 0 0in]{graphics/effCptModelTorsten_0.82/effCptPlots029.pdf}
\includegraphics[width=1.5in,trim=0in 0in 0 0in]{graphics/effCptModelTorsten_0.82/effCptPlots030.pdf}
\caption{{Predicted (posterior median and 90 \% credible intervals) and observed PD Response for example 2}}
\label{effCptModelPredictionsPD}
\end{figure}

\clearpage

\subsection{Example 4: Friberg-Karlsson Semi-Mechanistic Population Model} \ \\ 

We now return to example 2 and extend it to a population model. While we recommend using the mixed solver, for completeness we'll show how to specify the model with the \texttt{generalOdeModel\_*} function. We leave it as an exercise to the reader to rewrite the model with \texttt{mixOde2CptModel\_*}. 

{\bf Friberg-Karlsson Population Model for drug-induced myelosuppression ($ANC$)}

\begin{eqnarray*}
\log(ANC_{ij}) &\sim& N(Circ_{ij}, \sigma^2_{ANC}) \\
\log\left(MTT_j, Circ_{0j}, \alpha_j\right) &\sim& N\left(\log\left(\widehat{MTT}, \widehat{Circ_0}, \widehat{\alpha}\right), \Omega_{ANC}\right) \\
\left(\widehat{MTT}, \widehat{Circ}_0,\widehat{\alpha}, \gamma \right) &=& \left(125, 5, 2, 0.17\right) \\
\Omega_{ANC} &=& \left(\begin{array}{ccc} 0.2^2 & 0 & 0 \\ 0 & 0.35^2 & 0 \\ 0 & 0 & 0.2^2 \end{array}\right), \ \ \ \sigma_{ANC} = 0.1 \\
\Omega_{PK} &=& \left(\begin{array}{ccccc} 0.25^2 & 0 &a 0 & 0 & 0 \\ 0 & 0.4^2 & 0 & 0 & 0 \\
0 & 0 & 0.25^2 & 0 & 0 \\ 0 & 0 & 0 & 0.4^2 & 0 \\ 0 & 0 & 0 & 0 & 0.25^2  \end{array}\right)
\end{eqnarray*}

The PK and the PD data are simulated using the following treatment.
\begin{itemize}
  \item Phase IIa trial in patients
  \begin{itemize}
    \item Multiple doses: 80,000 mg
    \item Parallel dose escalation design
    \item 15 subjects
    \item PK: plasma concentration of parent drug ($c$)
    \item PD response: Neutrophil count ($ANC$)
    \item PK measured at 0.083, 0.167, 0.25, 0.5, 0.75, 1, 2, 3, 4, 6, 8, 12, 18, and 24 hours
    \item PD measured once every two days for 28 days.
  \end{itemize}
\end{itemize}

Once again, we simultaneously fit the model to the PK and the PD data. Note that from a computational perspective, this is a much more difficult problem than the one we dealt with in the previous example. The nonlinear nature of the ODEs forces us to use a numerical solver, which is significantly slower than the linear methods we have employed so far. Because the ODE system of interest is non-stiff, we use the \textit{rk45} version of \texttt{genOdeModel}.

It pays off to construct informative priors. For instance, we could fit the PK data first, as was done in  example 1, and get informative priors on the PK parameters. The PD parameters are drug independent, so we can use information from the neutropenia literature. In this example, we choose to use weakly informative priors on the PK parameters and strongly informative priors on the PD parameters. 

Since it takes a long time to run the model, we only use 100 iterations per chain, and study what we can learn from this less than optimal scenario. It is worth noting that Stan, because of its highly efficient MCMC sampler, still does a reasonable job estimating the posterior distribution.

\begin{figure}
\caption{Stan language for coding an ODE system describing a Friberg-Karlsson Mechanism}
\begin{tiny}
\begin{center}
\begin{fmpage}{\textwidth - .75in}
\begin{lstlisting}[basicstyle=\tiny\ttfamily,mathescape=true,flexiblecolumns=true,frame=single,escapeinside=`']
    real[] twoCptNeutModelODE(real t,
			real[] x,
			real[] parms,
			real[] rdummy,
			int[] idummy){
    real CL = parms[1];
    real Q = parms[2];
    real V2 = parms[3];
    real V3 = parms[4];
    real ka = parms[5];
    real mtt = parms[6];
    real circ0 = parms[7];
    real gamma = parms[8];
    real alpha = parns[9];
    real k10 = CL / V2;
    real k12 = Q / V2;
    real k21 = Q / V3;
    real ktr = 4 / mtt;
    real dxdt[8];
    real conc;
    real EDrug;
    real transit1;
    real transit2;
    real transit3;
    real circ;
    real prol;
  
    dxdt[1] = -ka * x[1];
    dxdt[2] = ka * x[1] - (k10 + k12) * x[2] + k21 * x[3];
    dxdt[3] = k12 * x[2] - k21 * x[3];
    conc = x[2]/V1;
    EDrug = alpha * conc;
    // x[4], x[5], x[6], x[7] and x[8] are differences from circ0.
    prol = x[4] + circ0;
    transit1 = x[5] + circ0;
    transit2 = x[6] + circ0;
    transit3 = x[7] + circ0;
    circ = fmax(machine_precision(), x[8] + circ0); // Device for implementing a modeled 
                                                                              // initial condition
    dxdt[4] = ktr * prol * ((1 - EDrug) * ((circ0 / circ)^gamma) - 1);
    dxdt[5] = ktr * (prol - transit1);
    dxdt[6] = ktr * (transit1 - transit2);
    dxdt[7] = ktr * (transit2 - transit3);
    dxdt[8] = ktr * (transit3 - circ);

    return dxdt;
  }
\end{lstlisting}
\end{fmpage}
\end{center}
\end{tiny} 
\label{FKODECode}
\end{figure}

\begin{figure}
\caption{Stan language for fitting a Friberg-Karlsson model using \texttt{genCptModel\_rk45} (abstract)}
\begin{tiny}
\begin{center}
\begin{fmpage}{\textwidth - .75in}
\begin{lstlisting}[basicstyle=\tiny\ttfamily,mathescape=true,flexiblecolumns=true,frame=single,escapeinside=`']
transformed parameters {
                             $\vdots$
  for(i in 1:nSubjects) {

    parms[1] = thetaM[i, 1] * (weight[i] / 70)^0.75; # CL
    parms[2] = thetaM[i, 2] * (weight[i] / 70)^0.75; # Q
    parms[3] = thetaM[i, 3] * (weight[i] / 70); # V1
    parms[4] = thetaM[i, 4] * (weight[i] / 70); # V2
    parms[5] = kaHat; # ka
    parms[6] = thetaM[i, 5]; # mtt
    parms[7] = thetaM[i, 6]; # circ0
    parms[8] = gamma;
    parms[9] = thetaM[i, 7]; # alpha

    x[start[i]:end[i]] = `\textcolor{red}{generalOdeModel\_rk45}'(twoCptNeutModelODE, 8,
                                                           time[start[i]:end[i]], 
                                                           amt[start[i]:end[i]], 
                                                           rate[start[i]:end[i]], 
                                                           ii[start[i]:end[i]], 
                                                           evid[start[i]:end[i]], 
                                                           cmt[start[i]:end[i]], 
                                                           addl[start[i]:end[i]], 
                                                           ss[start[i]:end[i]],
                                                           parms, biovar, tlag,
                                                           1e-6, 1e-6, 1e6);

    cHat[start[i]:end[i]] = x[start[i]:end[i], 2] / parms[1][3]; # divide by V1
    neutHat[start[i]:end[i]] = x[start[i]:end[i], 8] + parms[1][7]; # Add baseline
    
  }
  
  cHatObs = cHat[iObsPK];
  neutHatObs = neutHat[iObsPD];

                             $\vdots$  
\end{lstlisting}
\end{fmpage}
\end{center}
\end{tiny} 
\label{FKCode}
\end{figure}

\subsubsection*{Results} The MCMC history plots are not as convincing as in the previous examples, mostly because the number of iterations is small (100 versus 1000 in the previous example). It does however look as though the chains are converging to a common distribution, and we see little auto-correlation (in particular, we  expect that if we had run the model for 1000 iterations, we would obtain the desired ``fuzzy caterpillar" look). The plots of the marginal posterior distributions clearly show that the chains have not (yet) converged to a common distribution, but they do not disagree significantly. Still, the need for more iterations is evident. The model fits the data, and the credible interval reflect the noise in the data. The parameters estimation reflects the real value of the parameters.

{\tiny
\begin{table}[!htb]
\centering
\caption{Summary of the MCMC simulations of the marginal posterior distributions of the model parameters for example 3}
\begin{tabular}{rrrrrrrrrrr}
  \hline
 & mean & se\_mean & sd & 2.5\% & 25\% & 50\% & 75\% & 97.5\% & n\_eff & Rhat \\ 
  \hline
CL & 9.986 & 0.009 & 0.174 & 9.641 & 9.872 & 9.982 & 10.107 & 10.331 & 400.000 & 0.997 \\
Q & 14.633 & 0.055 & 1.106 & 12.505 & 13.992 & 14.623 & 15.296 & 16.948 & 400.000 & 0.996 \\
V1 & 32.909 & 0.174 & 2.439 & 28.203 & 31.186 & 32.836 & 34.762 & 37.750 & 195.828 & 1.008 \\
V2 & 106.631 & 0.311 & 6.226 & 95.234 & 102.269 & 106.403 & 111.000 & 118.533 & 400.000 & 0.999 \\
ka & 1.882 & 0.012 & 0.175 & 1.582 & 1.756 & 1.871 & 2.006 & 2.223 & 196.052 & 1.007 \\
sigma & 0.106 & 0.001 & 0.010 & 0.089 & 0.098 & 0.105 & 0.112 & 0.132 & 259.693 & 1.009 \\
alpha & 3.3E-04 & 1.4E-06 & 2.2E-05 & 2.9E-04 & 3.2E-04 & 3.3E-04 & 3.5E-04 & 3.8E-04 & 247 & 1.01 \\
mtt & 132.763 & 0.515 & 6.498 & 120.843 & 128.082 & 132.223 & 136.694 & 146.845 & 159.372 & 1.024 \\
circ0 & 5.014 & 0.009 & 0.172 & 4.711 & 4.888 & 5.000 & 5.138 & 5.334 & 400.000 & 1.000 \\
gamma & 0.190 & 0.002 & 0.022 & 0.153 & 0.175 & 0.187 & 0.202 & 0.239 & 139.485 & 1.025 \\
sigmaNeut & 0.092 & 0.001 & 0.014 & 0.068 & 0.082 & 0.090 & 0.100 & 0.125 & 161.199 & 1.010 \\
  \hline
\end{tabular}
\end{table} 
}

\begin{figure}[htbp]
\includegraphics[width=3.0in,trim=0in 0in 0 0in]{graphics/neutropenia_0.82/neutropeniaPopulationPlots001.pdf}
\includegraphics[width=3.0in,trim=0in 0in 0 0in]{graphics/neutropenia_0.82/neutropeniaPopulationPlots002.pdf}
\includegraphics[width=3.0in,trim=0in 0in 0 0in]{graphics/neutropenia_0.82/neutropeniaPopulationPlots003.pdf}
\includegraphics[width=3.0in,trim=0in 0in 0 0in]{graphics/neutropenia_0.82/neutropeniaPopulationPlots004.pdf}
\caption{{MCMC history plots for the parameters of a Friberg-Karlsson semi-mechanistic model (each color corresponds to a different chain) for example 3}}
\label{FKMCMC}
\end{figure}

\begin{figure}[htbp]
\includegraphics[width=2.5in,trim=0in 0in 0 0in]{graphics/neutropenia_0.82/neutropeniaPopulationPlots005.pdf}
\includegraphics[width=2.5in,trim=0in 0in 0 0in]{graphics/neutropenia_0.82/neutropeniaPopulationPlots006.pdf}
\caption{{Posterior Marginal Densities of the Model Parameters of a Friberg-Karlsson semi-mechanistic model (each color corresponds to a different chain)}}
\label{FKDens}
\end{figure}

\begin{figure}[htbp]
\includegraphics[width=2.5in,trim=0in 0in 0 0in]{graphics/neutropenia_0.82/neutropeniaPopulationPlots010.pdf}
\includegraphics[width=2.5in,trim=0in 0in 0 0in]{graphics/neutropenia_0.82/neutropeniaPopulationPlots011.pdf}
\caption{{Predicted (posterior median and 90 \% credible intervals) and observed plasma drug concentrations, and Neutrophil counts, for a Friberg-Karlsson semi-mechanistic model}}
\label{FKPredictions}
\end{figure}
 
\clearpage

\appendix

\section*{TECHNICAL APPENDIX}

\epigraph{
\textit{[Pharmacokinetic's] very essence is the use of mathematical
formulations based on certain biophysical or biochemical models of the
living body, and we must never forget that we are dealing with models, not necessarily
realistic facts. [...] And yet, it cannot be denied that classical mathematical
pharmacokinetics have been proved to be extremely useful for description,
explanation, and even prediction of the distribution of drugs and have
helped ``optimize'' drug administration. \\ \ \\
But sometimes pharmacokinetics in its present state is a failure - where
the basic assumptions are not valid or are too simplified. In fact, for an
oldtimer it is surprising that such an almost naive simple model as the
serial multicompartment governed by Fick's diffusion has survived over the
years. One way of explaining this is to state that the model may not represent
``a diffusional compartment model'' at all, but be rather a special case of
``sequential chain of first-order reactions,'' which has an identical mathematical
formalism.}}{Torsten Teorell \\ Concluding
remarks in \textit{Pharmacology and Pharmacokinetics}, 1974 \cite{Teorell:1974}}. 


Pharmacometrics is the application of quantitative methods to pharmacology,
and has been used to model a broad and diverse range of biomedical 
processes. The success of quantitative modeling may stem from the
fact similar ``mathematical formalisms'' keep arising again and again; for
that matter not only in pharmacometrics, but in all quantitative sciences.
This demands care and caution when we make scientific interpretations, but
presents many practical advantages. In a way, Torsten, like other pharmacometrics 
softwares out there, is a tool to make these mathematical formalisms more readily 
available to modelers. The math, while it may be treated abstractly, is here applied
to and always motivated by a scientific problem.


Broadly speaking, pharmacometrics
combines biomedicine, biochemistry, mathematics, and statistics. We
go a step further when we deal with its software implementation,
as we begin to consider problems pertinent
to computer science, computational statistics, and numerical analysis. 
Geometry, it turns out, plays a crutial role and makes some of the theory
behind statistical modeling very compelling visually. Mathematical
physics, to the delight of one of Torsten's developers, also contributes
its fair share.

It is no surprise then that an open-source project, such as Stan or Torsten, 
brings together scientists with a broad array of backgrounds, which greatly 
enriches the project, but sometimes makes communication difficult. This 
appendix attempts to ease conversation between experts in different fields 
and should be of interest to advanced users and potential contributors. 
\textit{The details covered here are not required to use Torsten}.

The focus is on Torsten's design and the algorithms it uses. We point readers
to references for more detailed descriptions, and also suggest improvements
that can be made to Torsten's current version.

A full understanding of this appendix requires a good knowledge of several topics.
Most readers cannot be expected to be experts in all these fields, which is
why we review some elementary facts.


\section{Bayesian Data Analysis with Stan} \ \\
Stan is primarily designed for Bayesian data analysis. It provides users with great flexibility,
 both for implementing stochastic and deterministic features. This allows users to specify 
 complex mixed-effect models, as the ones we may encounter in pharmacometrics.

Its default algorithm for full bayesian inference is the No-U-Turns Sampler (NUTS) \cite{HoffmanGelman:2014}. 
NUTS, an adaptative Hamiltonian Monte Carlo (HMC) \cite{Radford:2010} algorithm, has proven more
efficient than commonly used random walk Monte Carlo Markov Chains algorithms, such as 
Metropolis-Hastings and Gibbs sampling, for complex high-dimensional problems \cite{HoffmanGelman:2014}. 
Here, by ``complex" we mean non-trivial relationships between the independent and dependent
variables, such as ones that involve solving ODEs or hierarchical structures. The dimensionality of a model 
relates to the number of parameters.

\subsection{Hamiltonian Monte Carlo} \ \\

For this appendix, a quick review will do. For a more detailed introduction on the subject, see 
Betancourt's \textit{Conceptual Introduction to Hamiltonian Monte Carlo} \cite{Betancourt:2017}.  

The basic idea behind HMC is to treat the Markov chain as a \textit{particle} that moves in the
parameter space and the posterior as a \textit{physical potential} that informs the dynamic of
that particle. The potential, $U$, is defined as the negative of the log posterior, $\pi$:

\begin{eqnarray}
U = - \log(\pi)
\label{eq:potential}
\end{eqnarray}

Instead of taking a random step, the chain is given a random shove or momentum. The
 particle's acceleration is given by the negative change in potential. This is exactly what 
 we observe when a ball rolls on a hill under the influence of gravity: it accelerates when
  it rolls down (i.e as the gravitational potential weakens), but looses speed when it goes
   up. We replicate this behavior by applying the laws of classical mechanics, elegantly 
   described by Hamilton's equations, to our Markov chain.

Under these circumstances, the chain takes ``bigger steps'' when the posterior increases, 
but smaller ones when it moves towards regions of lower density. This results in several
 desirable properties, that allow the chain to explore the \textit{typical set}, i.e the region 
 with the most density mass, efficiently, especially as we get to high dimensions.

When applying Hamilton's equations to our MCMC problem, we can show the $j^{th}$ 
component of the chain's momentum, $p$, varies as the negative partial derivative of 
the potential with respect to the position in the parameter space, $q$:

$$
p_j' = - \frac{\partial{U}}{\partial{q_j}}
$$

Recalling our definition of the potential (equation~\ref{eq:potential}), the vectorized 
expression of the above equation is:

\begin{eqnarray}
p' = - \nabla_q \log(\pi(q))
\label{eq:gradient}
\end{eqnarray}

To simulate Hamiltonian dynamics, we must therefore \textit{compute the gradient 
of the log posterior with respect to the parameters}. Considering the posterior may have
a complex expression, this is not a trivial task. 

\subsection{Automatic Differentiation} \ \\

To compute gradients, Stan uses \textit{reverse automatic differentiation}. The posterior, 
$\pi$, gets ``translated'' into an expression graph and the gradients calculated by 
applying the chain rule at the nodes of the graph \cite{Carpenter:2015}. These nodes represent 
operators and functions used in $\pi$, such as the addition (\texttt{+}) operator or 
the exponential (\texttt{exp}) function.

Let $q \in \mathbb{R}^n$ be parameters and $x \in \mathbb{R}^k$ fixed data. For 
automatic differentiation to work, a function in Stan, $f: \mathbb{R}^{n + k} \mapsto \mathbb{R}^m$, 
must compute the output, $f(q, x)$, and the $n \times m$ Jacobian, $J$, 
where $J_{i,j} = \partial f_i / \partial q_j$.

This can be done in two ways: either we explicitly code a method to compute $J$,
 or we write $f$ as an expression of other Stan functions and use automatic differentiation
  to calculate $J$. The latter method is by far the easiest one to code; but it may not always 
  be implementable, nor be the most efficient approach. 

At a C++ level, automatic differentiation requires the use of a new class, \texttt{var}, which
contains (1) the value of the variable and (2) its adjoint with respect to the log 
posterior\footnote{The adjoint of $x$ with respect to $f$ is the derivative of $f$
with respect to x.}. This introduces an important distinction between parameters,
with respect to which we need to calculate the gradient of the log posterior and 
which must therefore be coded as \texttt{var}, and data, which are more simply 
coded as \texttt{double}.

It is good practice to allow users to call a function with only fixed data arguments.
 Most of the time, this means that arguments which may be parameters are templated, 
 and can be passed as either \texttt{double} or \texttt{var} objects.

\clearpage

\section{Ordinary Differential Equations in Pharmacometrics}

The work presented here is, in part, adapted from a presentation we gave at the 2017 Stan 
Conference on \textit{Differential Equation Based Models in Stan} \cite{Margossian:2017}
and an informal article on \textit{Complex ODE Based Models}\footnote{see
\url{https://github.com/stan-dev/stan/wiki/Complex-ODE-Based-Models}.} by
Margossian.

Ordinary differential equations are a powerful tool to describe physical and
biological processes. They persevere across disciplines and keep arising in
a remarkable fashion. They are central to pharmacometrics and by 
extension to Torsten. While they can be given several physical interpretations,
their mathematical properties are common to all problems, which allows us to
develop general purpose tools.

\subsection{When do ordinary differential equations arise?} \ \\

We deal with an ordinary differential equation (ODE) when we want to determine a
function $y(t)$ at a specific time but only know the derivative of that function, $\mathrm{d}y/\mathrm{d}t$.
In other words, we know the rate at which a quantity of interest changes but not the quantity 
itself. In many scenarios, the rate depends on the quantity itself.

To get a basic intuition, consider the example of a gas container with a hole in it  
(figure~\ref{GasContainer}). We can think of the gas as being made of molecules that move 
randomly in the container. Each molecule has a small chance of leaking through the hole. Thus
the more molecules inside the container, the higher the number of escaping molecules per unit
time. If there are a large number of molecules and the gas behaves like a continuous fluid, we
observe that the more gas in the container, the higher the leakage. This statement can be 
written as the differential equation:

$$ \frac{dy}{dt} = -ky(t)$$

where $y$ is the amount of gas in the container and $k$ is a positive constant. Note
that $y' = \mathrm{d}y/\mathrm{d}t$ is an acceptable notation.

\begin{figure}[!htb]
\begin{center}
\includegraphics[width=3.0in,trim=0in 0in 0 0in]{graphics/gasInBox.png}
\caption{{Gas container with a hole. \textit{Gas molecules in a box move in a (approximatively)
random fashion. In the limit where we have a lot of particles and the gas behaves like a 
continuous fluid, the rate at which the gas leaks is proportional to the amount of gas in the container.
This physical process is described by the differential equation $ \mathrm{d}y/\mathrm{d}t = -ky(t)$, 
where $y$ is the amount of gas in the container.}}}
\label{GasContainer}
\end{center}
\end{figure}

In a pharmacokinetic-pharmacodynamic (PK/PD) compartment model, we treat physiological
components, such as organs, tissues, and circulating blood, as compartments between which
the drug flows and/or in which the drug has an effect. A compartment may refer to more than  
one physiological component. For example, the central compartment typically consists of the 
systemic circulation (the blood) plus tissues and organs into which the drug diffuses rapidly.

Just like our leaking gas in a container, the rate at which the quantity of drug changes depends
on the drug amount in the various compartments (in the limit where the drug behaves like a 
continuous substance). Things are slightly more complicated because instead of one box, 
we now deal with a network of containers. This results in a system of ordinary differential equations.

\subsection{An example: ODE system for the Two Compartment Model} \ \\

Consider the common scenario in which a patient orally takes a drug. The drug enters the body
through the gut and is then absorbed into the blood. From there it diffuses into and circulates back
and forth between various tissues and organs. Over time, the body clears the drug, i.e. the drug exits 
the body (for instance through urine)  (figure~\ref{TwoCptNice}).

Our model divides the patient's body into three compartments:
\begin{itemize}
  \item \textbf{The absorption compartment}: the gut
  \item \textbf{The central compartment}: the systemic circulation (blood) and tissues/organs 
  into which the drug diffuses rapidly
  \item \textbf{The peripheral compartment}: other tissues/organs into which the drug 
  distributes more slowly
\end{itemize}

We conventionally call this a \textit{Two Compartment Model}, which may seem odd since
 the model has three compartments. The idea is that the ``absorption compartment" doesn't
 really count. We adopt this convention mostly to agree with the community.

We describe the drug absorption using the following differential equations:

\begin{eqnarray}
  \begin{aligned}
  y_\mathrm{gut}' &= -k_a y_\mathrm{gut} \\
  y_\mathrm{cent}' &= k_a y_\mathrm{gut} - \left(\frac{CL}{V_\mathrm{cent}} + \frac{Q}{V_\mathrm{cent}} \right) y_\mathrm{cent} +  \frac{Q}{V_\mathrm{peri}} y_\mathrm{peri} \\
  y_\mathrm{peri}' &= \frac{Q}{V_\mathrm{cent}} y_\mathrm{cent} - \frac{Q}{V_\mathrm{peri}} y_\mathrm{peri}
  \end{aligned}
  \label{eq:2Cpt}
\end{eqnarray}

with \\  
$y_\mathrm{gut}$ : the drug amount in the gut (mg)  \\
$y_\mathrm{cent}$ : the drug amount in the central compartment (mg)  \\
$y_\mathrm{peri}$ : the drug amount in the peripheral compartment (mg)  \\
$k_a$ : the rate constant at which the drug flows from the gut to the central compartment ($h^{-1}$)  \\
$Q$ : the clearance at which the drug flows back and forth between the central and the peripheral compartment (L/h) \\ 
$CL$ : the clearance at which the drug is cleared from the central compartment (L/h)  \\
$V_\mathrm{cent}$ : the volume of the central compartment (L)  \\
$V_\mathrm{peri}$ : the volume of the peripheral compartment (L) \\

\begin{figure}[!htb]
\begin{center}
\includegraphics[width=4in,trim=0in 0in 0 0in]{graphics/TwoCptNice.png}
\caption{{Two Compartment Model. \textit{An orally administered drug enters the body through
the gut and is then absorbed into the blood, organs, and tissues of the body, before being cleared out.}}}
\label{TwoCptNice}
\end{center}
\end{figure}


\subsection{Overview of Tools for Solving Differential Equations} \ \\

Solving ODEs can be notoriously hard.

In the best case scenario, an ODE system has an analytical solution we can hand-code
(as we have done for the one and two compartment models). The vast majority of times,
we need to approximate the solution numerically. There exists a very nice technique, 
involving matrix exponentials, for solving linear ODEs. Nonlinear systems are significantly 
more difficult but fortunately we can tackle these problems with numerical integrators.

Specialized algorithms for solving ODEs tend be more efficient but have a narrower application; 
the reverse holds for more general tools. We provide both, thereby allowing users to tackle a 
broad range of problems and optimize their model when possible  (figure~\ref{DiffEqTools}).

\begin{figure}[!htb]
\begin{center}
\includegraphics[width=5in,trim=0in 0in 0 0in]{graphics/ODEsolvers_ext.png}
\caption{{The ``Optimized-Applicable Spectrum" of tools for solving ODEs. \textit{The top 
line gives the technique to solve differential equations, the next line the type of ODE 
system this method should be applied to, and the third line (blue) an example from 
pharmacometrics, discussed in the user manual. Modelers should prefer the left-most 
applicable technique.}}}
\label{DiffEqTools}
\end{center}
\end{figure}

\subsection{The Event Schedule}

\subsubsection{Handling exterior interventions} \ \\

The ODE system only describes the natural evolution of the patient's system, that is 
how the drug behaves once it is already in the body. Describing this natural evolution, 
by solving ODEs, is the task of the \textit{evolution operator}. This operator does not 
account for exterior interventions during the treatment, such as the intake of a drug 
dose. To be accurate, our model must compute these exterior events and solve ODEs
in the context of an \textit{event schedule}.

We follow the convention set by NONMEM\textregistered\footnote{NONMEM\textregistered\ 
is licensed and distributed by ICON Development Solutions.}, which is popular amongst 
pharmacometricians and which we find acceptable.

An event can either be a change in the state of the system or the measurement of a certain 
quantity. We distinguish two types of events:
\begin{enumerate}
  \item \textbf{State Changer}: an (exterior) intervention that alters the state of the 
  system (for example, a bolus dosing, or the beginning of an infusion)
  \item \textbf{Observation}: the measurement of a quantity of interest at a certain time
\end{enumerate}

Between two subsequent events, the ODEs fully describe the PK/PD system. Knowing 
the state $y_0$ at time $t_0$ fully defines the solution at finite times. Exploiting this 
property, Torsten calculates amounts in each compartment from one event to the other.
 The initial conditions of the ODEs are specified by the previous event and the states 
 evolved from $t_\mathrm{previous}$ to $t_\mathrm{current}$.

The user passes the event schedule using a data table. 

NONMEM's convention allows one row to code for multiple events. For example, a 
single row can specify a patient receives multiple doses at a regular time interval. Consider:

\texttt{TIME = 0, EVID = 1, CMT = 1, AMT = 1500, RATE = 0, ADDL = 4, II = 10, SS = 0}

This row specifies that a time 0 (\hbox{TIME = 0}), a patient receives a 1500 mg 
(\hbox{AMT = 1500}) drug dose (\hbox{EVID = 1}) in the gut (\hbox{CMT = 1}), and will 
receive an additional dose every 10 hours (\hbox{II = 10}) until the patient has taken a 
total of 5 doses (\hbox{ADDL = 4}, being the number of additional doses, + 1, the original 
dose). Such an event really corresponds to 5 dosing events. Torsten augments the event 
schedule accordingly, before solving the ODEs recursively from one event to the other.

In summary, each Torsten function:
\begin{enumerate}
  \item augments the event schedule to include all state changers
  \item calculates the amounts in each compartment at each event of the augmented schedule by
  \begin{enumerate}
    \item integrating the ODEs and computing the \textit{natural} evolution of the system
    \item computing the effects of state changers
  \end{enumerate}
  \item returns the amounts at each event of the original schedule.
\end{enumerate}

\subsubsection{Dosing Events} \ \\

Most state changers in pharmacometrics (though by no means all of them) are due to drug
intakes. A drug can be administered using a bolus intake or an infusion over a finite time.

To compute a bolus dose, Torsten simply adds the administered dose amount to the drug 
mass, $y(t)$, and then resumes integrating the ODEs. Letting $f(y, t) = y'(t)$ be the right-hand 
side of our ODE system, $m$ be administered amount and $\tau$ the time of the dosing, we get:

\begin{eqnarray}
  \begin{aligned}
  y(\tau ^ +) &= y(\tau^-) + m \\
  y(t) &= \int_{\tau ^ +} ^ t f(y, t') dt'
  \end{aligned}
\end{eqnarray}


The bolus dosing event introduces a discontinuity with respect to time (figure~\ref{fig:bolus}), 
and can (in theory) lead to issues, especially when the modeler tries to evaluate \textit{lag times}. 
We still need to characterize how important the resulting error is\footnote{see issue \#3 on 
\url{github.com/metrumresearchgroup/math/issues/3}.}. We test the computation of the Jacobian
by benchmarking automatic differentiation against finite differentiation.  As expected, the 
derivative is not properly evaluated at events which occur \underline{exactly} at the time 
of a ``dosing'', lag time accounted for. Seeing the lag times are continuous variables, this 
scenario seems unlikely. The test further reveals the Jacobian at other events gets properly 
evaluated\footnote{There may still be issues with numerical solvers. This has not yet been tested for.}.

\begin{figure}[!htb]
\begin{center}
\includegraphics[width = 2.5in, height = 2.5in, trim=0in 0in 0 0in]{graphics/BolusDose.pdf}
\includegraphics[width = 2.5in, height = 2.5in, trim=0in 0in 0 0in]{graphics/Infusion.pdf}
\caption{Simulated drug mass in a patient's gut after an oral drug administration 
\textit{\hbox{\textbf{(left)} At} $t = 2 \mathrm{h}$ a patient receives a $1200 \mathrm{mg}$
bolus dose. This creates a discontinuity in the drug mass, $y(t)$. This can be an issue
when $t_\mathrm{lag}$ is a parameter and thence $t$ a latent parameter. As the system evolves, 
the drug gets naturally cleared out of the gut and absorbed into the blood and other organs (see 
equation~\ref{eq:2Cpt}).  \textbf{(right)} A patient receives an infusion, starting at $t = 2\mathrm{h}$
at a rate of $R = 150\mathrm{mg/h}$. After 8 hours, the infusion stops and the drug mass decreases.
Figures generated with mrgsolve.}} 
\label{fig:bolus}
\end{center}
\end{figure}

Users can code an infusion by setting a non-zero rate. For example, 
\hbox{\texttt{\{AMT = 1200, RATE = 150, ...\}}} corresponds to an infusion of 150 unit mass per unit
time that will last 8 unit time (leading to a total of 1200 unit mass being administered). Torsten handles
this scenario by creating a new event at the end of the infusion time. For all events between the
beginning and end of the infusion, the rate in each compartment is augmented by the infusion rate,
$R$. Letting $\tau$ be the beginning, and $\delta$ the end of the infusion time, we get:

\begin{eqnarray}
  \begin{aligned}
  y(\delta) &= \int_\tau ^ \delta f(y, t') + R dt' \\
  y(t) &= \int_\delta ^ t f(y, t') dt'
  \end{aligned}
\end{eqnarray}

Note the upper-bound of the integral, $\delta = m / R$, can be a latent parameter if either $m$ or
$R$ is a parameter. In other words, we may need to compute $\partial y / \partial \delta$. This will
be relevant to our discussion on numerical integrators.


\subsubsection{Model Parameters}\label{modelParms} \ \\

In addition to passing the event schedule to a torsten function, modelers must specify the 
\textit{model parameters}:
\begin{itemize}
  \item $\theta$: parameters which appear in the ODE system
  \item $F$: the bioavailability fraction, specified for each compartment
  \item $t_\mathrm{lag}$: lag times, specified for each compartment
\end{itemize}

All continuous variables, including elements of the event schedule, can be passed as either 
parameters or fixed data. This demand some caution when we compute sensitivities. Handling 
$\theta$ is straightforward.  $F$ and $t_\mathrm{lag}$ on the other hand modify variables which
get passed to the evolution operator and create latent parameters. In particular, $F$ modifies 
the rate, $R$, for regular solutions and the amount, $m$, for steady state solutions.
$t_\mathrm{lag}$ alters the dosing time, $t$. \ \\

\begin{center}
  \begin{tabular}{c | c}
  Model Parameter & Latent Parameter(s) \\
  \hline
    $F$ & $R$ (non-steady state case) \\
         &  $m$  (steady state case) \\ 
   \hline
  $t_\mathrm{lag}$ & $t$ \\
  \end{tabular} \\
\end{center}

\clearpage

\section{Solving Ordinary Differential Equations} \ \\

We need to solve differential equations and compute the Jacobian of the solutions with
respect to the parameters. In Torsten, this tasks is carried out by the \textit{pred} functors,
which act as the \textit{evolution operators} (they compute the evolution of the system from
one state to the other between two events). 

\iffalse
In this section, we do not consider the
random noise which may perturb the system, rather we focus on the ``ideal'' underlying
signal. Once we are able to treat the latter, we can use statistical tools to deal with
noise in the measurement.
\fi

\subsection{Analytical Solution} \ \\

We hand-code the solution for the One and Two Compartment models with a first-order
absorption. The Jacobians are computed using automatic differentiation.

\subsection{The Matrix Exponential} \ \\

Consider a system of \underline{linear} differential equations:

$$ y^\prime(t) = Ky(t) $$

where $K$ is a constant matrix and $y$ a vector function. The solution to the equation is given by 

$$ y(t) = e^{tK} y_0$$

where $y_0$ is the initial condition and $e$ is the \textit{matrix exponential}, formally defined
by the convergent power series:

$$ e^{tK} = \sum_{n=0}^{\infty} \dfrac{(tK)^n}{n!} = I + tK + \frac{(tK)^2}{2} + \frac{(tK)^3}{3!} + ...$$

Looking at this definition, we clearly see the derivative of $e^{tK}$ is $Ke^{tK}$.

There exist several methods to compute the matrix exponential. Moler \& Van Loan provide
an excellent and detailed overview \cite{MolerAndVanLoan:2003}, and Rowland \& Weisstein 
a much briefer discussion \cite{ToddWeisstein}.

The \texttt{matrix\_exp()} function in Stan computes the matrix exponential. The exponential
 of a $2 \times 2$ matrix is calculated analytically \cite{ToddWeisstein}, provided that for a matrix:

$$   K = \left[\begin{array}{cc}
	a & b \\
	c & d
	\end{array}\right] $$ \\

the condition $ (a - d)^2 + 4bc > 0$ is verified.

For the general case, we use the Pad\'e approximation coupled with scaling and squaring. 
The  idea is to approximate the matrix exponential with the finite series:

\begin{eqnarray*}
  R_{pq}(K) &=& [D_{pq}(K)]^{-1}  N_{pq}(K)
\end{eqnarray*}

where

\begin{eqnarray*}
  N_{pq}(K) &=& \sum_{j=0}^p \frac{(p + q - j)! p!}{(p + q)! j! (p - j)!}A^j \\
  D_{pq}(K) &=& \sum_{j=0}^q \frac{(p + q - j)! q!}{(p + q)! j! (q - j)!}(-A)^j
\end{eqnarray*}

In the asymptotic limit, $(p, q) \rightarrow (\infty, \infty)$, we recover the  definition of the 
matrix exponential. Moler \& Van Loan \cite{MolerAndVanLoan:2003} demonstrate  the 
Pad\'e approximation is more efficient than the Taylor approximation\footnote{The Taylor
approximation computes the formal definition of the matrix exponential with a finite 
number of terms.}, particularly in cases where $||K||$ is small. For reasons which are beyond
the scope of this discussion, there are advantages to setting $p = q$ and computing the 
\textit{diagonal} Pad\'e approximation $R_{pp}$.

This method fails for large $||K||$ because of round-off errors. This is where the scaling 
and squaring comes into play. Noting the following property of the matrix exponential:

$$ e^K = (e^{K/m})^m $$

we rescale the argument of the Pad\'e approximation and exponentiate the final product 
by $m$.

The C++ library \textit{Eigen} \cite{Eigen:2013} contains an unsupported routine to compute the matrix 
exponential that uses the above-described method. The order of the approximation, i.e. 
the number of terms in the series, depends on the input matrix. We find Eigen's code promptly
goes to the $13^{\text{th}}$ order, except in very simple cases. We edit Eigen's code, so that
it may handle \texttt{var} types. The Jacobian of \texttt{matrix\_exp} is approximated by applying 
automatic differentiation to the Pad\'e approximation.

We can improve the current implementation of \texttt{matrix\_exp} in several ways. First, we should
hand-code the Jacobian, potentially using recommendations by Giles \cite{Giles:2008}. We suspect 
computing 13 terms in the Pad\'e approximation is overkill; Sidje recommends 6, which is the default 
he implements in his package \textit{Expokit} \cite{Sidje:1998}. We also want to take advantage of methods which 
allow us to directly compute the action of a matrix exponential on a vector. Recall our goal is to 
compute the solution $e^{Kt}y_0$.

\subsection{Numerical Integrators} \ \\

Stan provides two ODE integrators: a Runge-Kutta $4^\mathrm{th}/5^\mathrm{th}$ order, 
\texttt{integrate\_ode\_rk45}, which is relatively fast, and the slower but more robust backward
differentiation method,  \texttt{integrate\_ode\_bdf}, which can handle stiff systems of equations.

\subsubsection{Nonstiff and stiff systems} \ \\

Stiffness is not a mathematically rigorously defined property but here's the general 
idea\footnote{The wikipedia article on \textit{stiffness} is actually pretty good: 
\url{https://en.wikipedia.org/wiki/Stiff_equation}.}. When we solve an ODE numerically, we construct 
the solution -- the function $y$ -- one step at a time using a tangent approximation\footnote{This is, 
by the way, the reason why numerical integrators are so expensive. For the analytical or matrix 
exponential solutions, the function can be directly computed at the times of interest, without going 
through intermediate steps.}. If the step is small, we gain in precision but it takes more steps to build 
the solution. We therefore need to find a balance between precision and computational speed.

In a stiff equation, the rate at which the solution changes with respect to the independent variable 
(time in many examples) can vary dramatically from one region to the other. This makes it difficult 
to pick an appropriate step size and requires a specialized algorithm, such as the backward 
differentiation technique used by \texttt{integrate\_ode\_bdf}.

\subsubsection{Jacobian of the solution} \ \\

Given a vector of parameters, $\alpha \in \mathbb{R}^m$, and the solution function, 
$y \in \mathbb{R}^n$, we construct an $m \times n$ Jacobian. This is done by augmenting the 
original system with the state variables:

$$
J_{n, m} = \frac{\partial}{\partial \alpha_m}y_n
$$  

which correspond to the individual elements of the Jacobian. Moreover, we calculate 
$\frac{\mathrm{d}}{\mathrm{d}t}J_{n, m}$ and add it to the right-hand-side of the ODE system. By 
integrating the augmented system, we simultaneously solve for the solution, $y$, and the 
Jacobian, $J$. For more details, see section 13 of \textit{Carpenter et al.} \cite{Carpenter:2015}.

An analysis of the augmented system shows the computational cost scales up significantly 
with the number of original states in the system; and (to a lesser degree) with the number 
of parameters \cite{Margossian:2017b}. In most cases, the modeler has no control over the dimension 
of $y$. We will treat a notable exception in the next section. Keeping the number of parameters
 at a minimum is a matter of careful coding.

In Stan, the functor which defines an ODE system, must observe a strict signature:

\texttt{real[] foo (real t,  {\ \ \ \ \ \ \color{gray}// time} \\
\phantom{real[] foo (}real[] y, {\ \ \ \ \color{gray}// array of states} \\
\phantom{real[] foo (}real[] theta, {\color{gray}// array of parameters} \\
\phantom{real[] foo (}real[] x\_r, {\ \  \color{gray} // array of real data} \\
\phantom{real[] foo (}int[] x\_i) {\ \ \ \color{gray} // array of integer data}
                   }

This strict signature requires some careful bookkeeping, as we need to sort out which 
variables are parameters or fixed data. As we saw in section~\ref{modelParms}, it
may not be immediately obvious if a variable is a latent parameter.

\pagebreak

\subsection{Mixed Solvers} \ \\

In certain cases, an ODE system can be split into two:

\begin{eqnarray*}
  \begin{aligned}
  y_1(t)' &= f_1(y_1, t) \\
  y_2(t)' &= f_2(y_1, y_2, t) \\
  \end{aligned}
\end{eqnarray*}

where $y_1$ does \underline{not} depend on $y_2$. In this situation, we usually refer to $y_1$
as the \textit{forcing function}. If $y_1$ has a closed-form solution, we can use a \textit{mixed solver} 
to solve the system. The idea is to solve for $y_1$ analytically and then 
numerically integrate a \textit{reduced system} to find $y_2$. This requires we write $f_2$ in 
terms of the solution $y_1$ -- often a relatively complex expression -- rather than as an 
expression of the (more simple) derivative $y_1'$. 

The mixed solver thus presents a trade-off: it increases the complexity of the integrant 
but reduces the number of states we integrate numerically. The benefit turns out to overweight 
the cost, particularly with automatic differentiation. The gain in efficiency varies on a case-by-case 
basis. For the example of a Friberg-Karlsson model, the average speed-up is $49 \pm 14 \%$
 \cite{Margossian:2017b}.

A proper implementation of the mixed solver requires a hand-coded closed-form solution for $y_1$ 
and some careful bookkeeping. In Torsten, we take advantage of the built-in solution for the one and 
two compartment model. The user is required
to specify which PK forcing function he or she wishes to use and codes the reduced system. Torsten 
then follows the following coding scheme:

\texttt{y\_1 = f\_1; \\
y\_2 = integrate(f\_2); \\
return y = \{y\_1, y\_2\}; \\
  }

where \texttt{f\_1} is the analytical solution and \texttt{f\_2} a C++ functor which wraps the reduced
system the user passes to the Torsten function and observes the strict signature required by Stan's
built-in integrators. For the case of a One Compartment model forcing function, the wrapper follows 
the following coding scheme:

\texttt{real[] foo(real t, \\
\phantom{real[] foo(}real[] y \\
\phantom{real[] foo(}real[] theta,  \\
\phantom{real[] foo(}real[] x\_r, \\
\phantom{real[] foo(}int[] x\_i) \{ \\
%
 \phantom{  } \textcolor{gray}{// Get PK parameters} \\
 \phantom{  } thetaPK[0] = theta[0];  \textcolor{gray}{// CL} \\
 \phantom{  } thetaPK[1] = theta[1];  \textcolor{gray}{// VC} \\
 \phantom{  } thetaPK[2] = theta[2];  \textcolor{gray}{// ka} \\ \ \\
% 
 \phantom{  } \textcolor{gray}{// Get initial PK states} \\
 \phantom{  } \textcolor{gray}{// The last two components of theta should contain the initial PK states} \\
 \phantom{  }  init\_pk[0] = theta[theta.size() - 2]; \\
 \phantom{  }  init\_pk[1] = theta[theta.size() - 1]; \\ \ \\
%  
 \phantom{  }  \textcolor{gray}{// The last element of x\_r contains the initial time} \\
 \phantom{  }  dt = t - x\_r[x\_r.size() - 1]; \\ \ \\
% 
 \phantom{  }  y\_pk = fOneCpt(dt, thetaPK, init\_PK, x\_r); \\
 \phantom{  }  dydt = \textcolor{red}{f0}(dt, y, y\_pk, theta, x\_r, x\_i); \\ \ \\
%  
 \phantom{  }  return dydt; \\
\}
}
  
where \texttt{\textcolor{red}{f0}} is the reduced system the user provides. The reduced 
system accepts an additional argument, which allows us to pass the analytical solution \texttt{y\_pk}. 
Torsten takes care of the following bookkeeping tasks under the hood:
\begin{itemize}
  \item augmenting the array of parameters, \texttt{theta}, with the initial conditions for the forcing function.
  \item augmenting the array of data, \texttt{x\_r} with the initial time, so that the evolution operator
  for the forcing function, \texttt{fOneCpt}, knows between which times to evolve the forcing system.
\end{itemize}

These considerations extend to the case of a Two Compartment forcing function. We need to apply 
similar thinking when we deal with non-zero rates and steady state solutions.


\subsection{Rates} \ \\

The administration of a dose through an infusion alters the \textit{natural} ODE system, by 
adding a constant rate, $R$, to the derivative of the solution:

$$
y'(t) = f(y, t) + R
$$

The solution to this new ODE is worked out analytically for the One and Two compartment 
model, and for the general linear compartment model. In particular for the latter:

$$
y'(t) = K y(t) + R
$$

which gives us the solution:

$$
y(t) = e^{tK} (K^{-1}R + y_0) - K^{-1} R
$$ 

For the numerical case, the function which gets passed to the integrator is modified, by adding
 $R$ to the returned vector. If $R$ is an array of fixed data, \texttt{rate} gets passed using the argument
 \texttt{x\_r}.

If $R$ is an array of parameters, we augment \texttt{theta}. Unfortunately, Torsten currently has 
no mechanism to separate data and parameters within $R$. Often times, only the rate in the dosing
compartment is a parameter, while the others are fixed (and zero, for that matter). This means we 
pass more parameters to the ODE  than necessary. This implementation is ``safe'' and does not place
restrictions on the arguments the user passes to a Torsten function -- but it creates inefficiencies.

\subsection{Steady State Solution} \ \\

A steady state is reached when the dose input and the dose clearance cancel each other.

\begin{figure}[!htb]
\begin{center}
\includegraphics[width = 5in, height = 2.5in, trim=0in 0in 0 0in]{graphics/SS.png}
\caption{Simulated drug mass in a patient's gut at steady state. \textit{Every 12 hours, a patient
receives a drug administration. After being under this drug regiment for a certain period of time, 
the patient's system reaches a steady state. In this particular simulation, the drug administration
corresponds to the infusion of 1200 mg over 8 hours. Figure generated with mrgsolve.}}
\label{fig:steadyState}
\end{center}
\end{figure}

The brute force method to calculate a steady state would be to simulate a dosing regimen
for an extended period of time. While this works well in certain settings, it is not very efficient,
and sometimes not precise. A better approach is to exploit the definition of the steady state.
Let us suppose a treatment repeats itself every $\tau$ hours. In figure~\ref{fig:steadyState},
$\tau$ corresponds to the inter-dose interval. Then, once steady state has been reached,
we have:

\begin{eqnarray}
y(t_0) = y(t_0 + \tau)
\end{eqnarray}

where $t_0$ corresponds to the beginning of a dosing interval. This expression corresponds 
to an algebraic equation. Our goal is to solve for $y(t_0)$, the drug amount once the
patient has reached steady state (at the end of a dosing interval).

For the one and two compartment model, the solution can be worked out analytically. Similarly,
in the linear case, we can write a solution using the matrix exponential. In the nonlinear
case, we require a numerical algebraic solver.

\subsubsection{Algebraic Solver} \ \\

This next section is adapted from a document Michael Betancourt produced
when we were designing the algebraic solver\footnote{For the original, see
\url{http://discourse.mc-stan.org/t/implicit-function-theorem-math/264}}. 

Stan implements an algebraic solver, which uses Powell's hybrid method \cite{Powell:1970},
and computes the Jacobian of the solution using the implicit function theorem. A prototype
solver is available in Torsten 0.83 and a fully tested version will be available in Stan 2.17.

Solving any algebraic equation can be turned into a root-finding problem, that is we want
to solve $f(x^*, \theta) = 0$ for $x^* \in \mathbb{R}^N$ in the neighborhood of some starting 
point $x \in \mathbb{R}^N$, which often corresponds to an initial guess for the solution. Note we
made $f$ explicitly dependent on the model parameters which appear in the algebraic
equation, $\theta \in \mathbb{R}^K$. In addition, we need to calculate the sensitivities 
of $\theta$. This means computing the $N \times K$ Jacobian:

$$
J = \frac{\partial x^*}{\partial \theta}(x^*, \theta)
$$

Formally, given the function $f: X \times \Theta \mapsto Y$, the implicit function theorem
states that if $f$ satisfies some weak regulatory conditions in a neighborhood of the
starting point $(x, \theta)$ the roots are given by implicit functions, $x^* = h(y)$, where
$h:\Theta \mapsto X$ satisfies $f(h(y), y) = 0$. This allows us to define the desired
Jacobian as $\partial h(y) / \partial y$.

The implicit function theorem does not give us $h$ -- it only tells us that it exists. To
do so however, it explicitly constructs the Jacobian of $h(y)$, which is all we need!
Defining the two initial Jacobian matrices

$$
J_x(x, \theta) = \frac{\partial f}{\partial x} (x, \theta)
$$

and

$$
J_\theta = \frac{\partial f}{\partial \theta} (x, \theta),
$$

then the Jacobian of the roots is given by

$$
\frac{\partial h}{\partial \theta}(\theta) = - [J_x(h(\theta), \theta)]^{-1} J_y(h(\theta), \theta),
$$

assuming that $J_x$ is invertible.

The Jacobians $J_x$ and $J_\theta$ can be computed with automatic differentiation,
given the expression for $f$ is known, and Stan provides a method for matrix division. 

The invertibility condition for $J_x$ places severe restrictions on the structure of the
original problem. In particular, recall $X = \mathbb{R}^N$ and $\Theta = \mathbb{R}^K$,
and let $Y = \mathbb{R}^M$. Then $J_x$ is a $M \times N$ matrix and is invertible
if and only if $M = N$. In other words, we need as many unknowns as equations in our
algebraic system. Even then, $J_x$ can become singular if the roots are not uniquely
defined and other pathologies occur.

\clearpage

\section{Code Implementation of Torsten} \

Stan's \texttt{math} library is written in C++, which offers a great deal of speed and 
flexibility. The Stan language provides a very handy interface that allows us to focus 
on statistical modeling and saves us the trouble of doing extensive coding in C++.

At run time, a make file translates our Stan model into C++, which then gets compiled 
and executed. Accordingly, there are two steps to add a function to Stan: (1) write the 
procedure in C++, (2) expose the procedure to the language so users may use it in a 
Stan file.

Stan interfaces with higher level languages, such as R and Python. Torsten exists as a forked 
version of \texttt{math} and \texttt{stan}. Other repos remain unchanged.

Regularly, we merge Stan's latest release into Torsten.

\textit{Modifications in math.} All Torsten files are located in 
the Torsten directory, under \texttt{stan/math}. The
code can be found on GitHub: \url{https://github.com/metrumresearchgroup/math}.

\textit{Modifications in Stan.} We do further modifications in stan to expose Torsten's 
functions. We edit \texttt{function\_signatures.h} to expose \texttt{PKModelOneCpt}, \texttt{PKModelTwoCpt}, 
and \texttt{linOdeModel}. The general and mix ODE model functions are higher-order functions (i.e. they 
take another function as one of their arguments). They are exposed by directly modifying 
the grammar files, following closely the example of \texttt{integrate\_ode\_rk45} and \texttt{integrate\_ode\_bdf}.
The code can be found on GitHub: \url{https://github.com/metrumresearchgroup/stan}.

\clearpage


\bibliographystyle{custom}
\bibliography{alpha,custom}


\end{document}
